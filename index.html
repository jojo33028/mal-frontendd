<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Anime Wrapped</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

  <!-- Pako for .gz decompression -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

  <style>
    :root{
      --bg1:#050816;
      --bg2:#0b0f2a;
      --card:rgba(255,255,255,0.08);
      --card2:rgba(255,255,255,0.06);
      --stroke:rgba(255,255,255,0.14);
      --text:rgba(255,255,255,0.92);
      --muted:rgba(255,255,255,0.68);
      --accent:#7c3aed;
      --accent2:#22d3ee;
      --accent3:#fb7185;
      --good:#34d399;
      --bad:#fb7185;
      --warn:#fbbf24;
      --shadow: 0 18px 60px rgba(0,0,0,0.45);
      --radius: 22px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      overflow-x:hidden;
      background: radial-gradient(1200px 900px at 15% 10%, rgba(124,58,237,0.35), transparent 55%),
                  radial-gradient(900px 700px at 85% 20%, rgba(34,211,238,0.25), transparent 55%),
                  radial-gradient(1100px 900px at 50% 100%, rgba(251,113,133,0.20), transparent 55%),
                  linear-gradient(180deg, var(--bg1), var(--bg2));
      min-height:100vh;
    }

    /* soft animated glow */
    .glow {
      position: fixed;
      inset: -20%;
      pointer-events:none;
      background:
        radial-gradient(900px 700px at 25% 20%, rgba(124,58,237,0.25), transparent 60%),
        radial-gradient(800px 600px at 80% 35%, rgba(34,211,238,0.22), transparent 60%),
        radial-gradient(900px 700px at 50% 85%, rgba(251,113,133,0.18), transparent 60%);
      filter: blur(30px);
      animation: drift 14s ease-in-out infinite;
      opacity:0.9;
      z-index:0;
    }
    @keyframes drift{
      0%,100%{ transform: translate3d(0,0,0) scale(1); }
      50%{ transform: translate3d(2%, -2%, 0) scale(1.03); }
    }

    /* anime background image layer */
    .bg-anime {
      position: fixed;
      inset:0;
      background-size: cover;
      background-position: center;
      opacity: 0.18;
      filter: blur(0px) saturate(1.15) contrast(1.05);
      transform: scale(1.03);
      z-index:0;
      transition: opacity 700ms ease, background-image 700ms ease;
    }
    .bg-vignette{
      position:fixed;
      inset:0;
      background: radial-gradient(60% 55% at 50% 45%, transparent 0%, rgba(0,0,0,0.45) 70%, rgba(0,0,0,0.75) 100%);
      z-index:0;
      pointer-events:none;
    }

    /* top banner */
    .top-banner{
      position:sticky;
      top:0;
      z-index:5;
      padding:12px 16px;
      backdrop-filter: blur(12px);
      background: rgba(0,0,0,0.30);
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    .banner-text{
      text-align:center;
      letter-spacing: 0.6px;
      font-weight:700;
      color: rgba(255,255,255,0.9);
      text-shadow: 0 2px 20px rgba(124,58,237,0.35);
    }

    /* layout */
    .wrap{
      position:relative;
      z-index:2;
      max-width: 1120px;
      margin: 0 auto;
      padding: 18px 16px 80px;
      display:grid;
      gap: 18px;
      grid-template-columns: 1.1fr 0.9fr;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{ grid-template-columns: 1fr; }
    }

    .hero-card, .app-shell{
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .hero-card{
      min-height: 360px;
      position:relative;
    }
    .hero-inner{
      padding: 18px;
    }
    .hero-title{
      font-size: 34px;
      font-weight: 900;
      line-height: 1.05;
      margin: 0 0 10px;
      background: linear-gradient(90deg, rgba(255,255,255,0.95), rgba(34,211,238,0.85), rgba(251,113,133,0.85));
      -webkit-background-clip:text;
      background-clip:text;
      color: transparent;
    }
    .hero-sub{
      color: rgba(255,255,255,0.72);
      margin:0 0 14px;
      max-width: 55ch;
    }
    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
    }
    .chip{
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.86);
      font-weight:700;
      font-size: 13px;
      cursor:pointer;
      transition: transform 120ms ease, background 200ms ease, border 200ms ease;
      user-select:none;
    }
    .chip:hover{ transform: translateY(-1px); border-color: rgba(124,58,237,0.35); }

    /* app shell */
    .app-shell{
      position:relative;
    }
    .app-head{
      padding: 18px 18px 0;
    }
    .app-title{
      font-size: 24px;
      font-weight: 900;
      margin:0 0 6px;
    }
    .app-sub{
      margin:0 0 14px;
      color: rgba(255,255,255,0.70);
      font-size: 13.5px;
    }

    .panel{
      margin: 14px 18px 18px;
      padding: 14px;
      border-radius: 18px;
      background: rgba(0,0,0,0.20);
      border: 1px solid rgba(255,255,255,0.12);
    }

    label{
      display:block;
      margin: 10px 0 6px;
      font-weight:800;
      font-size: 12px;
      letter-spacing: 0.7px;
      color: rgba(255,255,255,0.72);
    }
    input[type="file"], input[type="text"], input[type="number"], textarea{
      width:100%;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.28);
      color: rgba(255,255,255,0.92);
      outline:none;
      transition: border 160ms ease;
    }
    input:focus, textarea:focus{ border-color: rgba(34,211,238,0.45); }
    textarea{ min-height: 86px; resize: vertical; }

    .btn-row{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }
    .btn{
      padding: 11px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: linear-gradient(180deg, rgba(124,58,237,0.30), rgba(124,58,237,0.16));
      color: rgba(255,255,255,0.92);
      font-weight:900;
      cursor:pointer;
      transition: transform 120ms ease, filter 200ms ease, border 200ms ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); filter: brightness(1.08); border-color: rgba(124,58,237,0.45); }
    .btn.secondary{
      background: linear-gradient(180deg, rgba(34,211,238,0.22), rgba(34,211,238,0.12));
    }
    .btn.ghost{
      background: rgba(0,0,0,0.20);
    }
    .btn.danger{
      background: linear-gradient(180deg, rgba(251,113,133,0.30), rgba(251,113,133,0.14));
    }
    .hint{
      color: rgba(255,255,255,0.66);
      font-size: 12.5px;
      margin-top: 6px;
      line-height: 1.35;
    }
    .err{
      color: rgba(251,113,133,0.95);
      font-weight:800;
      margin-top:10px;
      display:none;
    }

    /* Slides modal */
    .modal{
      position: fixed;
      inset:0;
      background: rgba(0,0,0,0.52);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 999;
    }
    .modal.show{ display:flex; }

    .slides-card{
      width: min(980px, 100%);
      max-height: min(680px, 86vh);
      border-radius: 22px;
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .slides-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 14px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.18);
    }
    .slides-top .title{
      font-weight: 950;
      letter-spacing: 0.3px;
    }
    .slides-top .right{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .pill{
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.14);
      color: rgba(255,255,255,0.84);
      font-size: 12px;
      font-weight: 800;
      white-space:nowrap;
    }

    .slides-body{
      padding: 16px;
      overflow:auto;
      max-height: calc(min(680px, 86vh) - 120px);
    }

    .slide{
      display:none;
      gap: 12px;
      padding: 18px;
      border-radius: 20px;
      background: rgba(0,0,0,0.20);
      border: 1px solid rgba(255,255,255,0.12);
    }
    .slide.active{ display:grid; grid-template-columns: 1.1fr 0.9fr; }
    @media (max-width: 860px){
      .slide.active{ grid-template-columns: 1fr; }
    }

    .slide h2{
      margin:0 0 6px;
      font-size: 22px;
      font-weight: 950;
    }
    .slide p{
      margin:0;
      color: rgba(255,255,255,0.72);
      line-height: 1.4;
      font-size: 13.5px;
    }

    .kpi{
      display:grid;
      gap:10px;
      align-content:start;
    }
    .kpi .box{
      padding: 12px;
      border-radius: 16px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
    }
    .kpi .label{
      font-size:12px;
      color: rgba(255,255,255,0.68);
      font-weight: 900;
      letter-spacing: 0.7px;
      margin:0 0 4px;
    }
    .kpi .val{
      font-size: 20px;
      font-weight: 950;
      margin:0;
    }

    .slides-nav{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 12px 14px;
      border-top: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.18);
      gap:10px;
      flex-wrap:wrap;
    }
    .slides-nav .left{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .slides-nav .right{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    /* Now playing toast (bottom, not center) */
    #nowPlayingToast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      z-index: 10000;
      display:none;
      gap: 10px;
      align-items:center;
      padding: 10px 12px;
      border-radius: 14px;
      backdrop-filter: blur(12px);
      background: rgba(10, 14, 40, 0.72);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      color: rgba(255,255,255,0.92);
      font-size: 13px;
      max-width: min(720px, 92vw);
    }
    #nowPlayingToast .label{
      font-weight: 950;
      white-space:nowrap;
    }
    #nowPlayingToast .text{
      overflow:hidden;
      text-overflow: ellipsis;
      white-space:nowrap;
      color: rgba(255,255,255,0.78);
    }
    #nowPlayingToast .x{
      margin-left:auto;
      width:28px;
      height:28px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.25);
      color: rgba(255,255,255,0.9);
      cursor:pointer;
      font-weight: 950;
    }

    /* floating sound button */
    .sound-fab{
      position: fixed;
      top: 82px;
      right: 14px;
      z-index: 10001;
      width: 44px;
      height: 44px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.26);
      backdrop-filter: blur(12px);
      box-shadow: 0 14px 40px rgba(0,0,0,0.45);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      color: rgba(255,255,255,0.92);
      font-weight: 950;
    }
    .sound-fab:hover{ filter: brightness(1.08); }

  </style>
</head>

<body>
  <div class="glow"></div>
  <div class="bg-anime" id="bgAnime"></div>
  <div class="bg-vignette"></div>

  <div class="top-banner">
    <div class="banner-text">‚ú® Anime Wrapped ‚Äì Brought To You By MAL‚ÄôS API ‚Äì Your Year In Episodes ‚ú®</div>
  </div>

  <button class="sound-fab" id="muteBtn" title="Mute / Unmute">üîä</button>

  <!-- Toast bottom -->
  <div id="nowPlayingToast">
    <div class="label">Now Playing:</div>
    <div class="text" id="nowPlayingText">‚Äî</div>
    <button class="x" id="nowPlayingClose" title="Hide">√ó</button>
  </div>

  <div class="wrap">
    <div class="hero-card">
      <div class="hero-inner">
        <h1 class="hero-title">Your anime year,<br/>wrapped.</h1>
        <p class="hero-sub">
          Upload your MyAnimeList export or type your username. We‚Äôll generate a clean, shareable recap ‚Äî minutes watched, top titles,
          best/worst ratings, and Wrapped-style slides.
        </p>

        <div class="chips">
          <div class="chip" id="chipLocal">LOCAL TXT OR LOGIN WITH MAL</div>
          <div class="chip" id="chipFile">MAL XML / XML.GZ</div>
          <div class="chip" id="chipSlides">WRAPPED-STYLE SLIDES</div>
        </div>

        <div class="hint" style="margin-top:12px;">
          Tip: Add anime OP mp3s in <b>ops/</b> for per-slide music (example: <b>ops/attack-on-titan.mp3</b>).
          If missing, it falls back safely.
        </div>
      </div>
    </div>

    <div class="app-shell">
      <div class="app-head">
        <div class="app-title">Generate your Anime Wrapped.</div>
        <div class="app-sub">
          Upload your MyAnimeList anime export and we‚Äôll turn your watch history into a clean recap.
        </div>
      </div>

      <div class="panel">
        <label>MAL ANIME LIST EXPORT</label>
        <input id="malFile" type="file" accept=".xml,.gz,.txt" />
        <div class="hint">
          Export from MyAnimeList: Profile ‚Üí Export ‚Üí Anime List ‚Üí XML (the .xml or .xml.gz work).
        </div>

        <label>MAL USERNAME (OPTIONAL)</label>
        <input id="malUsername" type="text" placeholder="If no file, enter your MAL username" />
        <div class="hint">If you don‚Äôt upload a file, we‚Äôll try fetching via Jikan (public MAL data).</div>

        <label>MANUAL ANIME LIST (OPTIONAL)</label>
        <textarea id="manualList" placeholder="One line per anime: Title | episodes watched | score (optional) | type (optional) | start-date (optional) | finish-date (optional)"></textarea>

        <label>WRAPPED YEAR</label>
        <input id="yearInput" type="number" min="2000" max="2100" />

        <div class="btn-row">
          <button class="btn" id="generateBtn">Generate Wrapped</button>
          <button class="btn secondary" id="openSlidesBtn">Open Slides</button>
          <button class="btn ghost" id="bgTestBtn">Test Background + Music</button>
        </div>

        <div class="err" id="fileError"></div>
      </div>
    </div>
  </div>

  <!-- Slides Modal -->
  <div class="modal" id="slidesModal" aria-hidden="true">
    <div class="slides-card" role="dialog" aria-modal="true">
      <div class="slides-top">
        <div class="title">Anime Wrapped Slides</div>
        <div class="right">
          <div class="pill" id="slideIndicator">Slide ‚Äî</div>
          <button class="btn danger" id="closeSlidesBtn">Close</button>
        </div>
      </div>

      <div class="slides-body" id="slidesMain">
        <!-- Slides are injected here -->
      </div>

      <div class="slides-nav">
        <div class="left">
          <button class="btn ghost" id="prevSlideBtn">‚Üê Prev</button>
          <button class="btn ghost" id="nextSlideBtn">Next ‚Üí</button>
          <button class="btn secondary" id="restartBtn">Restart</button>
        </div>
        <div class="right">
          <div class="pill" id="slideCountPill">‚Äî</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Audio (two tracks for crossfade) -->
  <audio id="bgMusic" loop preload="auto">
    <source src="bg-music.mp3" type="audio/mpeg">
  </audio>

  <audio id="opMusic" loop preload="auto">
    <!-- starts empty; we set src in JS -->
    <source src="op-sample.mp3" type="audio/mpeg">
  </audio>

  <script>
    /**********************
     * Utilities
     **********************/
    const $ = (id) => document.getElementById(id);
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

    function safeText(x){
      return (x ?? "").toString().trim();
    }

    function normalizeKey(title){
      // Make filenames consistent: "Attack on Titan" -> "attack-on-titan"
      return safeText(title)
        .toLowerCase()
        .replace(/&/g, "and")
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/(^-|-$)/g, "");
    }

    /**********************
     * DOM refs (guarded)
     **********************/
    const bgAnimeEl = $("bgAnime");
    const muteBtn = $("muteBtn");
    const nowToast = $("nowPlayingToast");
    const nowText = $("nowPlayingText");
    const nowClose = $("nowPlayingClose");

    const malFile = $("malFile");
    const yearInput = $("yearInput");
    const fileError = $("fileError");
    const generateBtn = $("generateBtn");
    const openSlidesBtn = $("openSlidesBtn");
    const bgTestBtn = $("bgTestBtn");

    const malUsername = $("malUsername");
    const manualList = $("manualList");

    const slidesModal = $("slidesModal");
    const slidesMain = $("slidesMain");
    const closeSlidesBtn = $("closeSlidesBtn");
    const prevSlideBtn = $("prevSlideBtn");
    const nextSlideBtn = $("nextSlideBtn");
    const restartBtn = $("restartBtn");
    const slideIndicator = $("slideIndicator");
    const slideCountPill = $("slideCountPill");

    const chipLocal = $("chipLocal");
    const chipFile = $("chipFile");
    const chipSlides = $("chipSlides");

    const bgMusic = $("bgMusic");
    const opMusic = $("opMusic");

    const currentYear = new Date().getFullYear();
    if (yearInput) yearInput.value = currentYear;

    /**********************
     * Crossfade Audio Engine
     **********************/
    let muted = false;
    let userInteracted = false;

    // volumes you can tweak
    const BG_VOL = 0.35;
    const OP_VOL = 0.90;

    // fade ms
    const FADE_MS = 900;

    function setToast(text){
      if (!nowToast || !nowText) return;
      nowText.textContent = text || "‚Äî";
      nowToast.style.display = text ? "flex" : "none";
    }

    function hideToast(){
      if (!nowToast) return;
      nowToast.style.display = "none";
    }

    if (nowClose) nowClose.addEventListener("click", hideToast);

    function setMutedState(nextMuted){
      muted = !!nextMuted;
      if (muteBtn) muteBtn.textContent = muted ? "üîá" : "üîä";
      if (bgMusic) bgMusic.muted = muted;
      if (opMusic) opMusic.muted = muted;
    }

    if (muteBtn){
      muteBtn.addEventListener("click", () => {
        userInteracted = true;
        setMutedState(!muted);
      });
    }

    // smooth fade helper
    function fadeTo(audioEl, targetVol, ms){
      return new Promise((resolve) => {
        if (!audioEl) return resolve();
        const start = audioEl.volume ?? 0;
        const startT = performance.now();
        function tick(t){
          const p = clamp((t - startT) / ms, 0, 1);
          audioEl.volume = start + (targetVol - start) * p;
          if (p < 1) requestAnimationFrame(tick);
          else resolve();
        }
        requestAnimationFrame(tick);
      });
    }

    async function ensureBGPlaying(){
      if (!bgMusic) return;
      try {
        bgMusic.loop = true;
        if (!bgMusic.src) {
          // if source tag exists, browser resolves it
        }
        await bgMusic.play();
      } catch (e) {
        // autoplay blocked until user interacts; that's okay
      }
    }

    async function playOpeningForAnime(title){
      if (!opMusic || !bgMusic) return;

      const t = safeText(title);
      const key = normalizeKey(t);

      // Candidate OP file (you can add as many as you want to ops/)
      const candidate = `ops/${key}.mp3`;

      // Set src; if it 404s, browser will fail play() and we'll fallback to op-sample.mp3
      opMusic.src = candidate;

      try{
        opMusic.loop = true;

        // start both playing if possible
        await ensureBGPlaying();

        // Make sure OP can play
        await opMusic.play();

        // Crossfade: BG -> low, OP -> high
        await Promise.all([
          fadeTo(bgMusic, 0.08, FADE_MS),
          fadeTo(opMusic, muted ? 0 : OP_VOL, FADE_MS)
        ]);

        setToast(`Opening: ${t}`);
      }catch(err){
        // Fallback to sample OP (if candidate missing)
        try{
          opMusic.src = "op-sample.mp3";
          await opMusic.play();
          await Promise.all([
            fadeTo(bgMusic, 0.08, FADE_MS),
            fadeTo(opMusic, muted ? 0 : OP_VOL, FADE_MS)
          ]);
          setToast(`Opening: ${t} (fallback)`);
        }catch(e2){
          // If even fallback can't play, keep BG only
          await fadeTo(bgMusic, muted ? 0 : BG_VOL, FADE_MS);
          setToast(""); // hide
        }
      }
    }

    async function returnToBG(){
      if (!opMusic || !bgMusic) return;
      try{
        await Promise.all([
          fadeTo(opMusic, 0.0, FADE_MS),
          fadeTo(bgMusic, muted ? 0 : BG_VOL, FADE_MS)
        ]);
        opMusic.pause();
        setToast("");
      }catch(e){
        // ignore
      }
    }

    /**********************
     * Background image per anime
     **********************/
    // Put images in imgs/ folder if you want. Otherwise it still works without them.
    function setBackgroundForAnime(title){
      if (!bgAnimeEl) return;
      const key = normalizeKey(title);
      const img = `imgs/${key}.jpg`;
      bgAnimeEl.style.backgroundImage = `url('${img}')`;
      bgAnimeEl.style.opacity = 0.18;
    }

    function setDefaultBackground(){
      if (!bgAnimeEl) return;
      bgAnimeEl.style.backgroundImage = "";
      bgAnimeEl.style.opacity = 0.12;
    }

    /**********************
     * Data model for slides
     **********************/
    let wrappedData = null;
    let slides = [];
    let currentSlideIndex = 0;

    function showErr(msg){
      if (!fileError) return;
      fileError.textContent = msg;
      fileError.style.display = msg ? "block" : "none";
    }

    function parseManualLines(text){
      const lines = safeText(text).split("\n").map(l => l.trim()).filter(Boolean);
      const items = [];
      for (const line of lines){
        const parts = line.split("|").map(x => x.trim());
        const title = parts[0] || "";
        const eps = Number(parts[1] || 0) || 0;
        const score = parts[2] !== undefined ? Number(parts[2]) : null;
        items.push({ title, episodes: eps, score: Number.isFinite(score) ? score : null });
      }
      return items;
    }

    // Minimal MAL XML parser (enough for your stats)
    function parseMalXml(xmlText){
      const parser = new DOMParser();
      const xml = parser.parseFromString(xmlText, "text/xml");
      const anime = Array.from(xml.querySelectorAll("anime"));
      const items = anime.map(a => {
        const title = a.querySelector("series_title")?.textContent ?? "";
        const eps = Number(a.querySelector("my_watched_episodes")?.textContent ?? 0) || 0;
        const score = Number(a.querySelector("my_score")?.textContent ?? 0) || 0;
        return { title: safeText(title), episodes: eps, score: score || null };
      }).filter(x => x.title);
      return items;
    }

    async function readFileAsText(file){
      if (!file) return "";
      const name = file.name.toLowerCase();
      if (name.endsWith(".gz")){
        const buf = await file.arrayBuffer();
        const bytes = new Uint8Array(buf);
        const decompressed = window.pako.ungzip(bytes, { to: "string" });
        return decompressed;
      }
      return await file.text();
    }

    // Quick vibe club logic
    function computeClub(totalEpisodes, ratedCount, avgScore){
      if (totalEpisodes < 60) return { club: "Casual Viewer Club", vibe: "You watch at your own pace ‚Äî enough to keep up, not enough to lose sleep‚Ä¶ usually.", seedAnime: "Bocchi the Rock!" };
      if (avgScore >= 8.3) return { club: "Peak Enjoyer Club", vibe: "You don‚Äôt just watch anime ‚Äî you cultivate peak.", seedAnime: "Frieren" };
      if (ratedCount >= 120) return { club: "Certified Critic Club", vibe: "You rate everything. Your opinions have opinions.", seedAnime: "Death Note" };
      if (totalEpisodes > 500) return { club: "No-Sleep Club", vibe: "You might be the reason streaming servers overheat.", seedAnime: "One Piece" };
      return { club: "All-Rounder Club", vibe: "A little of everything ‚Äî you can vibe with any genre.", seedAnime: "Fullmetal Alchemist: Brotherhood" };
    }

    function buildWrapped(items, year){
      // stats
      const totalEpisodes = items.reduce((s,x)=> s + (x.episodes||0), 0);
      const rated = items.filter(x => Number.isFinite(x.score) && x.score !== null);
      const ratedCount = rated.length;
      const avgScore = ratedCount ? (rated.reduce((s,x)=>s+(x.score||0),0)/ratedCount) : 0;

      // most watched by episodes
      const mostWatched = [...items].sort((a,b)=>(b.episodes||0)-(a.episodes||0))[0] || null;

      // highest/lowest rated (ignore null)
      const scored = items.filter(x => Number.isFinite(x.score) && x.score !== null && x.score > 0);
      const highest = [...scored].sort((a,b)=>(b.score)-(a.score))[0] || null;
      const lowest = [...scored].sort((a,b)=>(a.score)-(b.score))[0] || null;

      const clubInfo = computeClub(totalEpisodes, ratedCount, avgScore);

      return {
        year,
        totalEpisodes,
        ratedCount,
        avgScore: avgScore ? avgScore.toFixed(2) : "‚Äî",
        mostWatched,
        highest,
        lowest,
        clubInfo,
        items
      };
    }

    /**********************
     * Slides: build + render
     **********************/
    function makeSlide({ id, title, body, animeTitle, kpis = [] }){
      return { id, title, body, animeTitle, kpis };
    }

    function buildSlides(data){
      const s = [];
      s.push(makeSlide({
        id:"intro",
        title:`This is your Anime Wrapped ${data.year}`,
        body:`A recap of your year ‚Äî episodes logged, ratings, and your top vibes.`,
        animeTitle: data.mostWatched?.title || data.clubInfo.seedAnime,
        kpis:[
          {label:"Episodes logged", val: data.totalEpisodes},
          {label:"Rated titles", val: data.ratedCount},
          {label:"Average score vibe", val: data.avgScore}
        ]
      }));

      if (data.mostWatched){
        s.push(makeSlide({
          id:"mostwatched",
          title:`Most Watched Anime`,
          body:`This year you watched the most episodes of:`,
          animeTitle: data.mostWatched.title,
          kpis:[
            {label:"Title", val: data.mostWatched.title},
            {label:"Episodes watched", val: data.mostWatched.episodes}
          ]
        }));
      }

      if (data.highest){
        s.push(makeSlide({
          id:"highest",
          title:`Highest Rated`,
          body:`Your top score went to:`,
          animeTitle: data.highest.title,
          kpis:[
            {label:"Title", val: data.highest.title},
            {label:"Score", val: data.highest.score}
          ]
        }));
      }

      if (data.lowest){
        s.push(makeSlide({
          id:"lowest",
          title:`Lowest Rated`,
          body:`Not everything can be peak‚Ä¶`,
          animeTitle: data.lowest.title,
          kpis:[
            {label:"Title", val: data.lowest.title},
            {label:"Score", val: data.lowest.score}
          ]
        }));
      }

      // club slide ‚Äî IMPORTANT: still plays a ‚Äúfit‚Äù anime OP
      s.push(makeSlide({
        id:"club",
        title:`The club you belong to`,
        body:`${data.clubInfo.club}\n\n${data.clubInfo.vibe}`,
        animeTitle: data.clubInfo.seedAnime,
        kpis:[
          {label:"Episodes logged", val: data.totalEpisodes},
          {label:"Rated titles", val: data.ratedCount},
          {label:"Average score vibe", val: data.avgScore}
        ]
      }));

      // End
      s.push(makeSlide({
        id:"end",
        title:`That‚Äôs a wrap.`,
        body:`Run it back anytime. Add more OP mp3s in ops/ to make every slide hit even harder.`,
        animeTitle: data.mostWatched?.title || data.clubInfo.seedAnime,
        kpis:[]
      }));

      return s;
    }

    function renderSlides(){
      if (!slidesMain) return;
      slidesMain.innerHTML = "";

      slides.forEach((sl, idx) => {
        const el = document.createElement("div");
        el.className = "slide" + (idx === 0 ? " active" : "");
        el.dataset.index = String(idx);

        const left = document.createElement("div");
        const h = document.createElement("h2");
        h.textContent = sl.title;
        const p = document.createElement("p");
        p.textContent = sl.body;

        left.appendChild(h);
        left.appendChild(p);

        const right = document.createElement("div");
        right.className = "kpi";

        (sl.kpis || []).forEach(k => {
          const box = document.createElement("div");
          box.className = "box";
          const l = document.createElement("p");
          l.className = "label";
          l.textContent = k.label;
          const v = document.createElement("p");
          v.className = "val";
          v.textContent = k.val;
          box.appendChild(l);
          box.appendChild(v);
          right.appendChild(box);
        });

        el.appendChild(left);
        el.appendChild(right);
        slidesMain.appendChild(el);
      });

      updateSlideUI();
    }

    function updateSlideUI(){
      if (!slidesMain) return;
      const els = Array.from(slidesMain.querySelectorAll(".slide"));
      els.forEach((el, i) => el.classList.toggle("active", i === currentSlideIndex));

      const total = slides.length;
      if (slideIndicator) slideIndicator.textContent = `Slide ${currentSlideIndex+1} of ${total}`;
      if (slideCountPill) slideCountPill.textContent = `${currentSlideIndex+1} / ${total}`;

      // enable/disable buttons safely
      if (prevSlideBtn) prevSlideBtn.disabled = currentSlideIndex === 0;
      if (nextSlideBtn) nextSlideBtn.disabled = currentSlideIndex === total - 1;

      // per-slide background + music
      const sl = slides[currentSlideIndex];
      if (sl?.animeTitle){
        setBackgroundForAnime(sl.animeTitle);
        // only play OP after user interacts at least once (browser policy)
        if (userInteracted) playOpeningForAnime(sl.animeTitle);
      }else{
        setDefaultBackground();
        if (userInteracted) returnToBG();
      }
    }

    function openSlides(){
      if (!slidesModal) return;
      slidesModal.classList.add("show");
      slidesModal.setAttribute("aria-hidden","false");
      updateSlideUI();
    }

    function closeSlides(){
      if (!slidesModal) return;
      slidesModal.classList.remove("show");
      slidesModal.setAttribute("aria-hidden","true");
      // optionally return to BG when closing
      if (userInteracted) returnToBG();
    }

    function nextSlide(){
      currentSlideIndex = clamp(currentSlideIndex + 1, 0, slides.length - 1);
      updateSlideUI();
    }

    function prevSlide(){
      currentSlideIndex = clamp(currentSlideIndex - 1, 0, slides.length - 1);
      updateSlideUI();
    }

    function restartSlides(){
      currentSlideIndex = 0;
      updateSlideUI();
    }

    /**********************
     * Generate flow
     **********************/
    async function fetchJikanList(username){
      // NOTE: Jikan doesn‚Äôt give watched episodes like the XML export,
      // so this is a light fallback. XML is best.
      const u = safeText(username);
      if (!u) return [];
      const url = `https://api.jikan.moe/v4/users/${encodeURIComponent(u)}/animelist?status=completed&limit=300`;
      const r = await fetch(url);
      if (!r.ok) throw new Error("Jikan request failed");
      const j = await r.json();
      const data = j.data || [];
      return data.map(x => ({
        title: x.entry?.title || "",
        episodes: x.episodes_watched || 0,
        score: x.score || null
      })).filter(x => x.title);
    }

    async function generateWrapped(){
      userInteracted = true; // this unlocks audio play
      showErr("");

      const year = Number(yearInput?.value || currentYear) || currentYear;

      let items = [];
      try{
        // priority: file
        const f = malFile?.files?.[0];
        if (f){
          const text = await readFileAsText(f);
          if (f.name.toLowerCase().endsWith(".txt")){
            items = parseManualLines(text);
          }else{
            items = parseMalXml(text);
          }
        } else {
          // manual text area
          const manual = safeText(manualList?.value);
          if (manual){
            items = parseManualLines(manual);
          } else {
            // username fallback
            const u = safeText(malUsername?.value);
            if (!u){
              showErr("Upload a MAL export (.xml/.xml.gz) OR type a username OR paste manual lines.");
              return;
            }
            items = await fetchJikanList(u);
          }
        }

        if (!items.length){
          showErr("No anime entries found. Try exporting again from MAL or check your file.");
          return;
        }

        wrappedData = buildWrapped(items, year);
        slides = buildSlides(wrappedData);
        currentSlideIndex = 0;

        renderSlides();
        openSlides();

        // Start BG
        if (bgMusic){
          bgMusic.volume = muted ? 0 : BG_VOL;
          await ensureBGPlaying();
        }

        // autoplay OP for first slide (after interaction)
        const firstAnime = slides[0]?.animeTitle || wrappedData.clubInfo.seedAnime;
        setBackgroundForAnime(firstAnime);
        await playOpeningForAnime(firstAnime);

      }catch(err){
        showErr("Generate failed. Check console for details.");
        console.error(err);
      }
    }

    /**********************
     * Wire buttons safely (no crashes if missing)
     **********************/
    function wire(){
      if (generateBtn) generateBtn.addEventListener("click", generateWrapped);

      if (openSlidesBtn) openSlidesBtn.addEventListener("click", () => {
        userInteracted = true;
        if (!slides.length && wrappedData) slides = buildSlides(wrappedData);
        if (!slides.length){
          showErr("Generate first, then open slides.");
          return;
        }
        renderSlides();
        openSlides();
      });

      if (closeSlidesBtn) closeSlidesBtn.addEventListener("click", closeSlides);
      if (slidesModal) slidesModal.addEventListener("click", (e) => {
        if (e.target === slidesModal) closeSlides();
      });

      if (nextSlideBtn) nextSlideBtn.addEventListener("click", () => { userInteracted = true; nextSlide(); });
      if (prevSlideBtn) prevSlideBtn.addEventListener("click", () => { userInteracted = true; prevSlide(); });
      if (restartBtn) restartBtn.addEventListener("click", () => { userInteracted = true; restartSlides(); });

      if (bgTestBtn) bgTestBtn.addEventListener("click", async () => {
        userInteracted = true;
        showErr("");
        try{
          await ensureBGPlaying();
          if (bgMusic){
            bgMusic.volume = muted ? 0 : BG_VOL;
          }
          setToast("Background music test (BG)");
          setTimeout(() => setToast(""), 1200);
        }catch(e){
          console.error(e);
          showErr("BG test failed. Make sure bg-music.mp3 exists beside index.html.");
        }
      });

      // chips (just UX)
      if (chipLocal) chipLocal.addEventListener("click", () => { userInteracted = true; malUsername?.focus(); });
      if (chipFile) chipFile.addEventListener("click", () => { userInteracted = true; malFile?.click(); });
      if (chipSlides) chipSlides.addEventListener("click", () => { userInteracted = true; openSlidesBtn?.click(); });

      // Start muted state false
      setMutedState(false);

      // Try start BG quietly (may be blocked until interaction)
      if (bgMusic){
        bgMusic.volume = 0.0;
        ensureBGPlaying().then(() => fadeTo(bgMusic, muted ? 0 : BG_VOL, 900));
      }
    }

    wire();
  </script>
</body>
</html>
