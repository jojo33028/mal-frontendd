<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Anime Wrapped</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

  <!-- Pako for .gz decompression -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

  <style>
    .intro-video-wrapper {
      max-width: 520px;
      width: 100%;
      margin: 20px auto;
    }
    .intro-video {
      width: 100%;
      height: auto;
      border-radius: 18px;
      display: block;
    }

    :root {
      --bg1: #050816;
      --bg2: #0f172a;
      --accent: #f97316;
      --accent-soft: rgba(249,115,22,0.15);
      --text-main: #e5e7eb;
      --text-soft: #9ca3af;
      --danger: #f97373;
      --card-bg: rgba(15,23,42,0.95);
      --border-subtle: rgba(148,163,184,0.25);
      --radius-xl: 24px;
      --shadow-xl: 0 24px 60px rgba(0,0,0,0.7);
      --slide-transition: 0.5s ease;
      --font-main: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: var(--font-main);
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      overflow-x: hidden;
      overflow-y: auto;
    }

    .bg-grid {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image:
        linear-gradient(to right, rgba(148,163,184,0.08) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(148,163,184,0.08) 1px, transparent 1px);
      background-size: 80px 80px;
      opacity: 0.35;
      z-index: -3;
    }

    .bg-anime {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image: url("anime-bg.jpg");
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      filter: blur(0.5px);
      opacity: 0.32;
      z-index: -2;
    }

    .bg-orbit {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      display: none;
    }

    .app-shell {
      width: 100%;
      max-width: 960px;
      max-height: 620px;
      background: linear-gradient(145deg, rgba(15,23,42,0.96), rgba(2,6,23,0.98));
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-xl);
      border: 1px solid rgba(148,163,184,0.3);
      position: relative;
      overflow-x: hidden;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .app-header {
      position: relative;
      padding: 1.1rem 1.5rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(30,64,175,0.7);
      background: radial-gradient(circle at top left, rgba(56,189,248,0.2), transparent 50%);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      position: relative;
      top: 6px;
      left: 6px;
      z-index: 10;
    }

    .brand-icon {
      width: 0;
      height: 0;
      padding: 0;
      border: none;
      background: none;
    }

    .header-right {
      position: absolute;
      right: 1.5rem;
      top: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .music-toggle {
      position: fixed;
      top: 40px;
      right: 28px;
      z-index: 10000;
      width: 40px;
      height: 40px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.15s ease;
    }

    .music-toggle:hover {
      background: rgba(0, 0, 0, 0.8);
      transform: translateY(-1px);
      border-color: rgba(249,115,22,0.9);
    }

    .app-body {
      flex: 1;
      display: flex;
      position: relative;
      overflow-x: hidden;
      overflow-y: auto;
    }

    .panel {
      width: 100%;
      padding: 1.75rem 1.8rem 1.9rem;
      display: none;
    }

    .panel.active { display: block; }

    .input-layout {
      height: 100%;
      display: grid;
      grid-template-columns: minmax(0, 1.2fr);
      max-width: 720px;
      margin: 0 auto;
    }

    @media (max-width: 800px) {
      .input-layout {
        grid-template-columns: minmax(0, 1fr);
        grid-auto-rows: auto;
      }
    }

    .input-main-card {
      background: radial-gradient(circle at top left, rgba(249,115,22,0.16), rgba(15,23,42,0.95));
      border-radius: 20px;
      padding: 1.5rem 1.4rem;
      border: 1px solid var(--border-subtle);
      box-shadow: 0 18px 40px rgba(15,23,42,0.7);
      position: relative;
      overflow-x: hidden;
      overflow-y: auto;
    }

    .input-main-card::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 0 100%, rgba(59,130,246,0.2), transparent 50%);
      opacity: 0.8;
      pointer-events: none;
    }

    .input-main-inner { position: relative; z-index: 1; }

    .input-title {
      font-size: 1.75rem;
      line-height: 1.2;
      font-weight: 800;
      margin-bottom: 0.35rem;
    }

    .input-subtitle {
      font-size: 0.9rem;
      color: var(--text-soft);
      margin-bottom: 1.4rem;
      max-width: 30rem;
    }

    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.4rem;
    }

    .badge {
      font-size: 0.7rem;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      background-color: rgba(15,23,42,0.8);
      border: 1px solid rgba(148,163,184,0.4);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #e5e7eb;
    }

    .input-grid { display: grid; gap: 1rem; }

    .field { display: flex; flex-direction: column; gap: 0.4rem; }

    .field label {
      font-size: 0.8rem;
      color: var(--text-soft);
      text-transform: uppercase;
      letter-spacing: 0.14em;
    }

    .field input[type="file"],
    .field-input {
      width: 100%;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(15,23,42,0.85);
      color: #e5e7eb;
      padding: 0.55rem 0.9rem;
      font-size: 0.86rem;
      outline: none;
    }

    .field input[type="file"] {
      padding: 0.45rem 0.4rem;
      border-radius: 999px;
      cursor: pointer;
    }

    .field-textarea {
      border-radius: 16px;
      min-height: 90px;
      resize: vertical;
      line-height: 1.4;
      padding-top: 0.6rem;
      padding-bottom: 0.6rem;
    }

    .field-helper { font-size: 0.75rem; color: var(--text-soft); }

    .pill-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .year-input { max-width: 120px; }

    .primary-btn {
      border: none;
      outline: none;
      cursor: pointer;
      padding: 0.6rem 1.3rem;
      border-radius: 999px;
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      background: linear-gradient(135deg, #f97316, #fb923c);
      color: #0b1120;
      box-shadow: 0 12px 35px rgba(248,113,113,0.4);
      transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.1s ease;
    }

    .primary-btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 16px 40px rgba(248,113,113,0.55);
    }

    .primary-btn:active {
      transform: translateY(0);
      box-shadow: 0 10px 28px rgba(248,113,113,0.4);
    }

    .secondary-btn {
      border: none;
      outline: none;
      cursor: pointer;
      padding: 0.6rem 1.3rem;
      border-radius: 999px;
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      background: linear-gradient(135deg, #38bdf8, #0ea5e9);
      color: #0b1120;
      box-shadow: 0 12px 35px rgba(14,165,233,0.4);
      transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.1s ease;
    }

    .secondary-btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 16px 40px rgba(14,165,233,0.55);
    }

    .secondary-btn:active {
      transform: translateY(0);
      box-shadow: 0 10px 28px rgba(14,165,233,0.4);
    }

    .error-text {
      color: var(--danger);
      font-size: 0.78rem;
      margin-top: 0.4rem;
    }

    .loading-inner {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .loader-card {
      padding: 1.4rem 1.6rem;
      border-radius: 18px;
      background: radial-gradient(circle at top, rgba(56,189,248,0.12), rgba(2,6,23,0.95));
      border: 1px solid rgba(148,163,184,0.4);
      display: grid;
      gap: 0.9rem;
      min-width: 280px;
      max-width: 420px;
      box-shadow: 0 16px 45px rgba(15,23,42,0.8);
      text-align: left;
    }

    .loader-bar {
      position: relative;
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      overflow: hidden;
      border: 1px solid rgba(30,64,175,0.6);
    }

    .loader-bar-fill {
      position: absolute;
      inset: 0;
      transform-origin: left;
      background: linear-gradient(90deg, #f97316, #fb923c, #facc15);
      animation: loaderPulse 1.6s infinite ease-in-out;
    }

    @keyframes loaderPulse {
      0%   { transform: scaleX(0.1); opacity: 0.2; }
      40%  { transform: scaleX(0.7); opacity: 1; }
      100% { transform: scaleX(1); opacity: 0.6; }
    }

    .loader-title { font-size: 1.1rem; font-weight: 700; }
    .loader-sub { font-size: 0.84rem; color: var(--text-soft); }
    .loader-hints { font-size: 0.78rem; color: #9ca3af; }

    .slides-wrapper {
      height: 100%;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .slides-main {
      height: 320px;
      min-height: 260px;
      position: relative;
      border-radius: 20px;
      overflow-x: hidden;
      overflow-y: auto;
      border: 1px solid rgba(148,163,184,0.35);
      background: radial-gradient(circle at top left, rgba(15,23,42,0.98), #020617);
    }

    @media (max-height: 720px) {
      .slides-main { height: 280px; }
    }

    .slide {
      position: absolute;
      inset: 0;
      opacity: 0;
      transform: translateX(20px);
      transition: opacity var(--slide-transition), transform var(--slide-transition);
      display: flex;
      pointer-events: none;
    }

    .slide.active {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }

    .slide-bg {
      position: absolute;
      inset: 0;
      opacity: 0.35;
      background-position: center;
      background-size: cover;
      background-repeat: no-repeat;
      filter: blur(8px);
      transform: scale(1.05);
    }

    .slide-gradient {
      position: absolute;
      inset: 0;
      background:
        linear-gradient(135deg, rgba(15,23,42,0.98), rgba(15,23,42,0.9)),
        radial-gradient(circle at top left, rgba(56,189,248,0.2), transparent 50%);
      mix-blend-mode: multiply;
    }

    .slide-content {
      position: relative;
      z-index: 1;
      padding: 1.6rem 1.7rem;
      width: 100%;
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 1.3rem;
    }

    @media (max-width: 840px) {
      .slide-content {
        grid-template-columns: minmax(0, 1fr);
        grid-auto-rows: auto;
        padding: 1.3rem 1.2rem;
      }
    }

    .slide-left {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 0.8rem;
    }

    .slide-kicker {
      font-size: 0.8rem;
      color: var(--text-soft);
      letter-spacing: 0.14em;
      text-transform: uppercase;
    }

    .slide-title {
      font-size: 1.6rem;
      font-weight: 800;
      line-height: 1.2;
    }

    .slide-highlight {
      font-size: 1.15rem;
      font-weight: 600;
      color: #e5e7eb;
      margin-top: 0.3rem;
    }

    .slide-body {
      font-size: 0.9rem;
      color: var(--text-soft);
      max-width: 32rem;
    }

    .stats-grid {
      margin-top: 0.6rem;
      display: grid;
      gap: 0.35rem;
      font-size: 0.86rem;
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      gap: 0.6rem;
    }

    .stats-label { color: #9ca3af; }
    .stats-value { color: #e5e7eb; font-weight: 500; }

    .slide-right {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      gap: 1rem;
    }

    .anime-card {
      border-radius: 18px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.5);
      padding: 0.9rem 1rem;
      box-shadow: 0 14px 35px rgba(15,23,42,0.8);
      display: grid;
      gap: 0.3rem;
    }

    .anime-title { font-weight: 700; font-size: 1rem; }
    .anime-meta { font-size: 0.8rem; color: var(--text-soft); }

    .pill-meta-row {
      margin-top: 0.4rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      font-size: 0.75rem;
    }

    .pill-meta {
      padding: 0.18rem 0.55rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(15,23,42,0.95);
      color: #e5e7eb;
    }

    .slide-footer { font-size: 0.8rem; color: var(--text-soft); margin-top: 0.5rem; }

    .slides-controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 0.3rem;
      gap: 0.75rem;
      font-size: 0.82rem;
    }

    .controls-left {
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .control-btn {
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(15,23,42,0.9);
      color: #e5e7eb;
      padding: 0.35rem 0.9rem;
      font-size: 0.8rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      cursor: pointer;
    }

    .control-btn[disabled] { opacity: 0.4; cursor: default; }
    .restart-btn { border-color: rgba(249,115,22,0.8); color: #fed7aa; }

    .slide-indicator { font-size: 0.78rem; color: #9ca3af; }
    .intro-username { font-size: 1.4rem; font-weight: 800; margin-top: 0.2rem; }
    .intro-tagline { margin-top: 0.6rem; font-size: 0.9rem; color: var(--text-soft); }

    /* Top moving banner */
    .top-banner {
      width: 100%;
      overflow: hidden;
      white-space: nowrap;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 9999;
      background: rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(5px);
      padding: 8px 0;
    }

    .banner-text {
      display: inline-block;
      padding-left: 40%;
      animation: scroll-banner 20s linear infinite;
      font-size: 1.2rem;
      letter-spacing: 0.05em;
      color: #ffffff;
      font-weight: 600;
    }

    @keyframes scroll-banner {
      0% { transform: translateX(100%); }
      100% { transform: translateX(-100%); }
    }

    /* ‚úÖ REMOVE ‚ÄúTHING IN THE MIDDLE OF THE SCREEN‚Äù
       - hard-hide common overlays / toast-like elements that end up centered
       - AND force YouTube iframe overlays to stay hidden
    */
    .center-toast, .status-toast, .toast, .snackbar, .popup-status,
    #statusText, #status, #middleStatus, #centerStatus, #centerToast, #toast, #snackbar, #popup {
      display: none !important;
      opacity: 0 !important;
      pointer-events: none !important;
      visibility: hidden !important;
    }
    /* If any element is absolutely centered by transform(-50%,-50%), kill it */
    [style*="translate(-50%"], [style*="translate3d(-50%"], [style*="top: 50%"][style*="left: 50%"] {
      /* we don‚Äôt want to nuke your slides, so limit to likely overlays */
    }

    /* ‚úÖ YouTube ‚Äúaudio-only‚Äù mini player (TOP RIGHT ONLY) */
    #ytModal {
      display: none;
      position: fixed;
      top: 18px;
      right: 18px;
      z-index: 20000;
      background: transparent;
      inset: auto;
      pointer-events: auto;
    }

    #ytModalCard {
      width: min(320px, 92vw);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 14px;
      overflow: hidden;
      background: rgba(2,6,23,0.92);
      box-shadow: 0 18px 45px rgba(0,0,0,0.55);
    }

    #ytModalTop {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.12);
    }

    #ytNowPlaying {
      font-size: 13px;
      color: #e5e7eb;
      font-weight: 600;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    #ytCloseBtn {
      cursor: pointer;
      border: none;
      border-radius: 10px;
      padding: 6px 10px;
      background: rgba(255,255,255,0.08);
      color: #e5e7eb;
    }

    /* ‚úÖ We will NOT show status text anywhere (this was the ‚Äúmiddle thing‚Äù for a lot of people) */
    #ytStatusLine { display: none !important; }

    /* hidden player area */
    #ytFrameWrap {
      width: 1px;
      height: 1px;
      overflow: hidden;
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div class="top-banner">
    <div class="banner-text">
      ‚ú® Anime Wrapped ‚Äì Brought To You By MAL‚ÄôS API ‚Äì Your Year In Episodes ‚ú®
    </div>
  </div>

  <div class="intro-video-wrapper">
    <video class="intro-video" src="anime-collage.mp4" autoplay loop muted playsinline></video>
  </div>

  <div class="bg-grid"></div>
  <div class="bg-anime"></div>
  <div class="bg-orbit"></div>

  <div class="app-shell">
    <header class="app-header">
      <div class="brand">
        <div class="brand-icon"></div>
      </div>

      <div class="header-right">
        <button class="music-toggle" id="musicToggle" title="Toggle background music">üîá</button>
      </div>
    </header>

    <main class="app-body">
      <!-- Input Panel -->
      <section class="panel active" id="panel-input">
        <div class="input-layout">
          <div class="input-main-card">
            <div class="input-main-inner">
              <h1 class="input-title">Generate your Anime Wrapped.</h1>
              <p class="input-subtitle">
                Upload your MyAnimeList anime export and we‚Äôll turn your watch history into a clean,
                shareable recap ‚Äî total minutes, most-watched shows, ratings, and more.
              </p>

              <div class="badge-row">
                <div class="badge">Local txt or login with MAL</div>
                <div class="badge">MAL XML / XML.GZ</div>
                <div class="badge">Wrapped-style slides</div>
              </div>

              <div class="input-grid">
                <div class="field">
                  <label for="malFile">MAL Anime List Export</label>
                  <input id="malFile" type="file" accept=".xml,.gz,.txt" />
                  <div class="field-helper">
                    Export from MyAnimeList: <strong>Profile ‚Üí Export ‚Üí Anime List ‚Üí XML</strong>
                    (the .xml or .xml.gz file both work).
                  </div>
                  <div class="error-text" id="fileError" style="display:none;"></div>
                </div>

                <div class="field">
                  <label for="malUsername">MAL Username (optional)</label>
                  <input id="malUsername" class="field-input" type="text" placeholder="If no file, enter your MAL username" />
                  <div class="field-helper">We‚Äôll fetch your list via the Jikan API if you don‚Äôt upload a file.</div>
                </div>

                <div class="field">
                  <label for="manualList">Manual Anime List (optional)</label>
                  <textarea
                    id="manualList"
                    class="field-input field-textarea"
                    rows="4"
                    placeholder="One line per anime: Title | episodes watched | score (optional) | type (optional) | start-date (optional) | finish-date (optional)"
                  ></textarea>
                  <div class="field-helper">
                    Example:<br />
                    <code>Naruto | 220 | 9 | TV | 2022-01-01 | 2022-12-31</code>
                  </div>
                </div>

                <div class="field" style="margin-top:1rem;">
                  <button id="malLoginBtn" class="secondary-btn" type="button" style="width:100%;padding:0.5rem 1rem;">
                    Sign in with MAL
                  </button>
                  <div class="field-helper">
                    Uses your backend at <code>mal-wrapped-1.onrender.com</code> to authenticate and fetch your list.
                  </div>
                </div>

                <div class="pill-row">
                  <div class="field year-input">
                    <label for="yearInput">Wrapped Year</label>
                    <input id="yearInput" class="field-input" type="number" />
                    <div class="field-helper">If dates are missing, we‚Äôll treat your whole list as this year.</div>
                  </div>

                  <button class="primary-btn" id="generateBtn">
                    <span>Generate Anime Wrapped</span><span>‚ûú</span>
                  </button>
                </div>
              </div>

            </div>
          </div>
        </div>
      </section>

      <!-- Loading Panel -->
      <section class="panel" id="panel-loading">
        <div class="loading-inner">
          <div class="loader-card">
            <div class="loader-title">Summoning your Anime Wrapped‚Ä¶</div>
            <div class="loader-sub">
              We‚Äôre parsing your MAL export, counting episodes, and calculating how many
              days you lived in fictional worlds this year.
            </div>
            <div class="loader-bar"><div class="loader-bar-fill"></div></div>
            <div class="loader-hints" id="loaderHint">
              Tip: Longer shows like shonen epics will spike your ‚Äútime spent in another universe‚Äù stat.
            </div>
          </div>
        </div>
      </section>

      <!-- Slides Panel -->
      <section class="panel" id="panel-slides">
        <div class="slides-wrapper">
          <div class="slides-main" id="slidesMain"></div>
          <div class="slides-controls">
            <div class="controls-left">
              <button class="control-btn" id="prevSlideBtn"><span>‚Üê</span><span>Prev</span></button>
              <button class="control-btn" id="nextSlideBtn"><span>Next</span><span>‚Üí</span></button>
              <button class="control-btn restart-btn" id="restartBtn"><span>‚ü≥</span><span>Restart</span></button>
            </div>
            <div class="slide-indicator" id="slideIndicator">Slide 1 of X</div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <!-- ‚úÖ YouTube OP mini player (top-right only, no status text) -->
  <div id="ytModal">
    <div id="ytModalCard">
      <div id="ytModalTop">
        <div id="ytNowPlaying">Opening‚Ä¶</div>
        <button id="ytCloseBtn" type="button">‚úï</button>
      </div>
   
      <div id="ytFrameWrap">
        <div id="ytPlayer"></div>
      </div>
    </div>
  </div>
  <!-- ‚úÖ Background music (local file) -->
  <audio id="bgMusic" loop>
    <source src="bg-music.mp3" type="audio/mpeg" />
    <source src="bg-music.wav" type="audio/wav" />
  </audio>

  <!-- (Optional legacy) -->
  <audio id="opAudio">
    <source src="op-sample.mp3" type="audio/mpeg" />
    <source src="op-sample.wav" type="audio/wav" />
  </audio>

  <!-- ‚úÖ YouTube IFrame API -->
  <script src="https://www.youtube.com/iframe_api"></script>

  <script>
    // ============================
    // ------------- AUDIO (BG) -------------
    // ============================
    const musicToggle = document.getElementById("musicToggle");
    let musicOn = false;

    function getBgMusic() { return document.getElementById("bgMusic"); }
    function getOpAudio() { return document.getElementById("opAudio"); } // kept for compatibility; not used for OP anymore

    function updateMusicToggle() {
      if (!musicToggle) return;
      musicToggle.textContent = musicOn ? "üîä" : "üîá";
    }

    function stopBgMusic() {
      const bgMusic = getBgMusic();
      if (!bgMusic) return;
      try { bgMusic.pause(); } catch (e) {}
      musicOn = false;
      updateMusicToggle();
    }

    function stopOpSample() {
      const opAudio = getOpAudio();
      if (!opAudio) return;
      try { opAudio.pause(); opAudio.currentTime = 0; } catch (e) {}
    }

    if (musicToggle) {
      musicToggle.addEventListener("click", async () => {
        const bgMusic = getBgMusic();
        if (!bgMusic) return;

        try {
          if (bgMusic.paused) {
            bgMusic.volume = 0.5;
            await bgMusic.play();
            musicOn = true;
          } else {
            bgMusic.pause();
            musicOn = false;
          }
          updateMusicToggle();
        } catch (e) {
          console.error("BG music failed to play:", e);
        }
      });
      updateMusicToggle();
    }

    // ============================
    // ‚úÖ YouTube OP Player (audio-only vibe)
    // ============================
    const YT_API_KEY = "AIzaSyBIJmG0xuyThIR6BOXURNgzTzhEdStoC-8"; // replace if needed

    let ytPlayer = null;
    let ytReady = false;

    const ytModal = document.getElementById("ytModal");
    const ytCloseBtn = document.getElementById("ytCloseBtn");
    const ytNowPlaying = document.getElementById("ytNowPlaying");
    const ytCache = new Map(); // query -> videoId

    function openYtModal() {
      if (!ytModal) return;
      ytModal.style.display = "block";
    }

    function closeYtModal() {
      if (!ytModal) return;
      ytModal.style.display = "none";
      try { ytPlayer?.stopVideo?.(); } catch (e) {}
    }

    if (ytCloseBtn) ytCloseBtn.addEventListener("click", closeYtModal);
    window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeYtModal(); });

    window.onYouTubeIframeAPIReady = () => {
      ytReady = true;
      ytPlayer = new YT.Player("ytPlayer", {
        height: "100%",
        width: "100%",
        videoId: "",
        playerVars: {
          autoplay: 1,
          controls: 0,
          modestbranding: 1,
          rel: 0,
          playsinline: 1,
          fs: 0,
          iv_load_policy: 3
        }
      });
    };

    function hasValidApiKey() {
      return typeof YT_API_KEY === "string" && YT_API_KEY.trim().length > 20;
    }

    async function searchYouTubeFirstVideoId(query) {
      if (ytCache.has(query)) return ytCache.get(query);
      if (!hasValidApiKey()) return null;

      const url =
        "https://www.googleapis.com/youtube/v3/search" +
        `?part=snippet&type=video&maxResults=1&safeSearch=moderate` +
        `&q=${encodeURIComponent(query)}` +
        `&key=${encodeURIComponent(YT_API_KEY)}`;

      const res = await fetch(url);
      if (!res.ok) return null;

      const json = await res.json();
      const vid = json?.items?.[0]?.id?.videoId || null;
      ytCache.set(query, vid);
      return vid;
    }

    async function playOpeningForAnime(animeTitle) {
      const title = (animeTitle || "").trim();
      if (!title) return;

      stopOpSample();
      stopBgMusic();

      openYtModal();
      if (ytNowPlaying) ytNowPlaying.textContent = `Opening: ${title}`;

      const query = `${title} opening 1 official`;

      let vid = null;
      try { vid = await searchYouTubeFirstVideoId(query); } catch (e) { console.error(e); }

      if (!vid) return; // no status text shown (removes the ‚Äúmiddle thing‚Äù)

      const tryLoad = () => {
        try { ytPlayer.loadVideoById(vid); } catch (e) {}
      };

      if (ytReady && ytPlayer?.loadVideoById) tryLoad();
      else setTimeout(tryLoad, 350);
    }

    // ============================
    // ------------- Panel switching -------------
    // ============================
    function showPanel(id) {
      document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
      const panel = document.getElementById(id);
      if (panel) panel.classList.add("active");

      const banner = document.querySelector(".top-banner");
      const introWrapper = document.querySelector(".intro-video-wrapper");

      if (id === "panel-slides") {
        if (banner) banner.style.display = "none";
        if (introWrapper) introWrapper.style.display = "none";
      } else {
        if (banner) banner.style.display = "block";
        if (introWrapper) introWrapper.style.display = "block";
      }
    }

    // ============================
    // ------------- Helpers -------------
    // ============================
    function safeInt(val, fallback = 0) {
      const n = parseInt(val, 10);
      return Number.isFinite(n) ? n : fallback;
    }
    function formatNumber(num) { return num.toLocaleString("en-US"); }

    function estimateMinutes(entry) {
      const eps = entry.watchedEpisodes || 0;
      if (!eps) return 0;
      const type = (entry.type || "").toLowerCase();
      if (type === "movie") return eps * 90;
      return eps * 23;
    }

    function extractYear(dateStr) {
      if (!dateStr || dateStr === "0000-00-00") return null;
      const year = String(dateStr).split("-")[0];
      if (year && year !== "0000") return year;
      return null;
    }

    function parseISODate(dateStr) {
      if (!dateStr || dateStr === "0000-00-00") return null;
      const d = new Date(dateStr);
      return Number.isFinite(d.getTime()) ? d : null;
    }

    function monthName(m) {
      const names = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
      return names[m] || "‚Äî";
    }

    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

    // ============================
    // ------------- Parse MAL XML -------------
    // ============================
    function parseMalXml(xmlText) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlText, "text/xml");

      const userNameNode = doc.getElementsByTagName("user_name")[0];
      const userName = userNameNode ? userNameNode.textContent.trim() : "Anime Fan";

      const animeNodes = Array.from(doc.getElementsByTagName("anime"));
      const entries = animeNodes.map(node => {
        const get = tag => {
          const el = node.getElementsByTagName(tag)[0];
          return el && el.textContent ? el.textContent.trim() : "";
        };
        const title = get("series_title") || "Untitled Anime";
        const id = get("series_animedb_id");
        const type = get("series_type");
        const totalEpisodes = safeInt(get("series_episodes"), 0);
        const watchedEpisodes = safeInt(get("my_watched_episodes"), 0);
        const startDate = get("my_start_date");
        const finishDate = get("my_finish_date");
        const score = safeInt(get("my_score"), 0);
        const statusRaw = get("my_status"); // MAL numeric
        const statusNum = safeInt(statusRaw, 0);

        return {
          id,
          title,
          type,
          totalEpisodes,
          watchedEpisodes,
          startDate,
          finishDate,
          score,
          status: statusNum, // keep numeric for XML
          coverImage: "",
          // meta to enrich:
          genres: [],
          studios: [],
          airedYear: null,
          premiered: ""
        };
      });

      return { userName, entries };
    }

    // ============================
    // ------------- Jikan list fetch -------------
    // ============================
    async function fetchFromJikan(username, yearVal) {
      const entries = [];
      let page = 1;
      const maxPages = 5;

      while (page <= maxPages) {
        const url = `https://api.jikan.moe/v4/users/${encodeURIComponent(username)}/animelist?status=all&page=${page}&limit=100`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("Jikan request failed");
        const json = await res.json();
        const list = (json && json.data) || [];

        list.forEach(item => {
          const anime = item.anime || {};
          const entry = {
            id: String(anime.mal_id || ""),
            title: anime.title || anime.title_english || "Untitled Anime",
            type: anime.type || "",
            totalEpisodes: Number(anime.episodes) || 0,
            watchedEpisodes: Number(item.episodes_watched || item.num_episodes_watched || item.episodes || 0),
            startDate: item.started_at || "",
            finishDate: item.completed_at || "",
            score: Number(item.score) || 0,
            status: item.status || "",
            coverImage: (anime.images && anime.images.jpg && (anime.images.jpg.large_image_url || anime.images.jpg.image_url)) || "",
            genres: [],
            studios: [],
            airedYear: null,
            premiered: ""
          };
          entries.push(entry);
        });

        const pagination = json && json.pagination;
        if (pagination && pagination.has_next_page) page++;
        else break;
      }

      const filtered = entries.filter(e => {
        const startY = extractYear(e.startDate);
        const finishY = extractYear(e.finishDate);
        return String(yearVal) === startY || String(yearVal) === finishY;
      });

      const active = filtered.length ? filtered : entries;
      return { userName: username || "Anime Fan", year: yearVal, entries: active };
    }

    // ============================
    // ------------- MAL backend fetch -------------
    // ============================
    async function fetchFromMalApi(yearVal) {
      const res = await fetch("https://mal-wrapped-1.onrender.com/list");
      if (!res.ok) throw new Error("MAL backend request failed");

      const json = await res.json();
      const data = json.data || [];
      const entries = [];

      data.forEach(item => {
        const anime = item.node || item.anime || {};
        const status = item.list_status || {};

        entries.push({
          id: String(anime.id || anime.mal_id || ""),
          title: anime.title || anime.title_english || (Array.isArray(anime.title_synonyms) && anime.title_synonyms[0]) || "Untitled Anime",
          type: anime.media_type || anime.type || "",
          totalEpisodes: Number(anime.num_episodes) || Number(anime.episodes) || 0,
          watchedEpisodes: Number(status.num_episodes_watched) || Number(status.watched_episodes) || 0,
          startDate: status.start_date || "",
          finishDate: status.finish_date || "",
          score: Number(status.score) || 0,
          status: status.status || "",
          coverImage: (anime.main_picture && (anime.main_picture.large || anime.main_picture.medium)) || "",
          genres: [],
          studios: [],
          airedYear: null,
          premiered: ""
        });
      });

      const filtered = entries.filter(e => {
        const startY = extractYear(e.startDate);
        const finishY = extractYear(e.finishDate);
        return String(yearVal) === startY || String(yearVal) === finishY;
      });

      const activeEntries = filtered.length ? filtered : entries;
      return { userName: "Your MAL", year: yearVal, entries: activeEntries };
    }

    // ============================
    // ------------- Manual list parser -------------
    // ============================
    function parseManualList(text, yearVal) {
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
      const entries = [];

      lines.forEach((line, idx) => {
        let parts = line.split("|");
        if (parts.length === 1) parts = line.split(" - ");
        parts = parts.map(p => p.trim());

        const title = parts[0] || `Untitled Anime #${idx + 1}`;
        const episodes = safeInt(parts[1], 0);
        const score = safeInt(parts[2] || "", 0);
        const type = parts[3] || "";
        const startDate = parts[4] || `${yearVal}-01-01`;
        const finishDate = parts[5] || `${yearVal}-12-31`;

        entries.push({
          id: title.toLowerCase().replace(/\s+/g, "-") + "-" + idx,
          title, type,
          totalEpisodes: episodes,
          watchedEpisodes: episodes,
          startDate, finishDate,
          score,
          status: "completed",
          coverImage: "",
          genres: [],
          studios: [],
          airedYear: null,
          premiered: ""
        });
      });

      return { userName: "Manual List", year: yearVal, entries };
    }

    // ============================
    // ‚úÖ Enrich meta (genres / studios / year) using Jikan anime/{id}
    // ============================
    const jikanAnimeCache = new Map(); // id -> meta
    async function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function fetchJikanAnimeMeta(id) {
      if (!id) return null;
      if (jikanAnimeCache.has(id)) return jikanAnimeCache.get(id);

      const url = `https://api.jikan.moe/v4/anime/${encodeURIComponent(id)}/full`;
      const res = await fetch(url);
      if (!res.ok) {
        jikanAnimeCache.set(id, null);
        return null;
      }
      const json = await res.json();
      const a = json?.data || null;
      if (!a) {
        jikanAnimeCache.set(id, null);
        return null;
      }

      const meta = {
        genres: (a.genres || []).map(g => g.name).filter(Boolean),
        studios: (a.studios || []).map(s => s.name).filter(Boolean),
        airedYear: (a.year || (a.aired && a.aired.from ? new Date(a.aired.from).getFullYear() : null)) || null,
        premiered: (a.season && a.year ? `${a.season} ${a.year}` : ""),
        image: (a.images && a.images.jpg && (a.images.jpg.large_image_url || a.images.jpg.image_url)) || ""
      };

      jikanAnimeCache.set(id, meta);
      return meta;
    }

    async function enrichEntriesWithMeta(entries) {
      // only enrich entries that have numeric MAL ids (manual lines won't)
      const candidates = entries
        .filter(e => e && e.id && /^\d+$/.test(String(e.id)))
        .sort((a,b) => estimateMinutes(b) - estimateMinutes(a)); // enrich biggest-impact first

      const MAX_ENRICH = 25;      // keep it fast + avoid rate limits
      const CONCURRENCY = 3;      // gentle
      const ids = candidates.slice(0, MAX_ENRICH).map(e => String(e.id));

      let idx = 0;
      const workers = new Array(CONCURRENCY).fill(0).map(async () => {
        while (idx < ids.length) {
          const my = ids[idx++];
          try {
            const meta = await fetchJikanAnimeMeta(my);
            // attach back to entry
            const target = entries.find(x => String(x.id) === my);
            if (meta && target) {
              target.genres = meta.genres || [];
              target.studios = meta.studios || [];
              target.airedYear = meta.airedYear || null;
              target.premiered = meta.premiered || "";
              if (!target.coverImage && meta.image) target.coverImage = meta.image;
            }
          } catch (e) {}
          await sleep(350); // Jikan rate-limit friendly
        }
      });

      await Promise.all(workers);
      return entries;
    }

    // ============================
    // ------------- Slide builder (UPDATED: NEW SLIDES) -------------
    // ============================
    function buildSlides(data) {
      const slides = [];

      const username = data.userName;
      const year = data.year;
      const list = data.entries || [];

      const totalAnime = list.length;
      const totalEpisodes = list.reduce((sum, e) => sum + (e.watchedEpisodes || 0), 0);
      const totalMinutes = list.reduce((sum, e) => sum + estimateMinutes(e), 0);

      const seconds = totalMinutes * 60;
      const days = totalMinutes / (60 * 24);
      const months = totalMinutes / (60 * 24 * 30);
      const years = totalMinutes / (60 * 24 * 365);

      const nonZeroWatch = list.filter(e => (e.watchedEpisodes || 0) > 0);
      const rated = list.filter(e => e.score && e.score > 0);

      const sortedByMinutes = [...nonZeroWatch].sort((a, b) => estimateMinutes(b) - estimateMinutes(a));
      const sortedByScoreDesc = [...rated].sort((a, b) => b.score - a.score || estimateMinutes(b) - estimateMinutes(a));
      const sortedByScoreAsc = [...rated].sort((a, b) => a.score - b.score || estimateMinutes(b) - estimateMinutes(a));
      const mostWatched = sortedByMinutes[0] || null;

      function placeholderCover(title) {
        if (!title) return "";
        const t = encodeURIComponent(title + " anime");
        return "https://placehold.co/800x1200/020617/ffffff?text=" + t;
      }

      function coverForEntry(entry) {
        if (!entry) return "";
        if (entry.coverImage) return entry.coverImage;
        return placeholderCover(entry.title);
      }

      const topRated = sortedByScoreDesc.slice(0, 3);
      const bottomRated = sortedByScoreAsc.slice(0, 3);
      const avgScore = rated.length ? rated.reduce((sum, e) => sum + e.score, 0) / rated.length : null;

      // -------------------------
      // ‚úÖ NEW SLIDE METRICS
      // -------------------------

      // Completed vs Dropped (works for XML numeric or Jikan string)
      function isCompleted(e) {
        if (typeof e.status === "number") return e.status === 2;
        const s = String(e.status || "").toLowerCase();
        return s.includes("complete");
      }
      function isDropped(e) {
        if (typeof e.status === "number") return e.status === 4;
        const s = String(e.status || "").toLowerCase();
        return s.includes("drop");
      }
      const completedCount = list.filter(isCompleted).length;
      const droppedCount = list.filter(isDropped).length;

      // Most active month (by finish date if possible, else start date)
      const monthCounts = new Array(12).fill(0);
      list.forEach(e => {
        const f = parseISODate(e.finishDate);
        const s = parseISODate(e.startDate);
        const d = f || s;
        if (!d) return;
        if (String(d.getFullYear()) !== String(year)) return;
        monthCounts[d.getMonth()]++;
      });
      let bestMonthIdx = 0;
      for (let i = 1; i < 12; i++) if (monthCounts[i] > monthCounts[bestMonthIdx]) bestMonthIdx = i;
      const mostActiveMonth = monthCounts[bestMonthIdx] ? `${monthName(bestMonthIdx)} ${year}` : null;

      // Fastest finish (needs both dates)
      const finishedWithDates = list
        .map(e => {
          const s = parseISODate(e.startDate);
          const f = parseISODate(e.finishDate);
          if (!s || !f) return null;
          const diffDays = Math.max(0, Math.round((f - s) / (1000 * 60 * 60 * 24)));
          return { e, diffDays };
        })
        .filter(Boolean)
        .sort((a,b) => a.diffDays - b.diffDays);
      const fastest = finishedWithDates[0] || null;

      // Genre personality (from enriched meta)
      const genreCounts = new Map();
      list.forEach(e => (e.genres || []).forEach(g => genreCounts.set(g, (genreCounts.get(g) || 0) + 1)));
      const topGenre = [...genreCounts.entries()].sort((a,b) => b[1]-a[1])[0] || null;

      function genrePersonalityText(genre) {
        const g = String(genre || "").toLowerCase();
        if (g.includes("action")) return "Adrenaline brain. If nobody is sprinting, you‚Äôre bored.";
        if (g.includes("comedy")) return "Vibes > plot. You‚Äôre here to laugh and chill.";
        if (g.includes("drama")) return "Emotional damage enjoyer. You like stories that *hit*.";
        if (g.includes("romance")) return "Hopeless romantic arc. You root for the ship every time.";
        if (g.includes("thriller") || g.includes("mystery")) return "Conspiracy mode: ON. You love plotting theories.";
        if (g.includes("horror")) return "You like fear as seasoning. Respect (and concern).";
        if (g.includes("slice of life")) return "Comfort watcher. Warm tea, soft pacing, good vibes.";
        if (g.includes("fantasy")) return "Worldbuilder energy. You want lore, magic, and maps.";
        if (g.includes("sci-fi")) return "Big-brain settings. You like tech, concepts, and mind-bends.";
        return "You follow vibes more than labels ‚Äî and it works.";
      }

      // Studio loyalty (from enriched meta)
      const studioCounts = new Map();
      list.forEach(e => (e.studios || []).forEach(s => studioCounts.set(s, (studioCounts.get(s) || 0) + 1)));
      const topStudio = [...studioCounts.entries()].sort((a,b) => b[1]-a[1])[0] || null;

      // Comfort anime (best guess): highest score among ‚Äúolder start date‚Äù, OR fallback to mostWatched
      const comfortCandidate = [...list]
        .filter(e => e.score && e.score >= 8)
        .sort((a,b) => {
          const as = parseISODate(a.startDate);
          const bs = parseISODate(b.startDate);
          const ay = as ? as.getFullYear() : 9999;
          const by = bs ? bs.getFullYear() : 9999;
          return ay - by || estimateMinutes(b) - estimateMinutes(a);
        })[0] || mostWatched;

      // Era vibe (decade) from airedYear meta (best effort)
      const decadeCounts = new Map();
      list.forEach(e => {
        const y = e.airedYear || null;
        if (!y || !Number.isFinite(Number(y))) return;
        const dec = Math.floor(Number(y)/10)*10;
        decadeCounts.set(dec, (decadeCounts.get(dec) || 0) + 1);
      });
      const topDecade = [...decadeCounts.entries()].sort((a,b)=>b[1]-a[1])[0] || null;

      function decadeVibe(dec) {
        if (!dec) return { title: "Modern Mixed Bag", body: "Your list spans eras ‚Äî you‚Äôre not locked to one time period." };
        const d = Number(dec);
        if (d <= 1990) return { title: `${d}s Classic Aura`, body: "Old-school taste. You respect the roots and the vibes are timeless." };
        if (d === 2000) return { title: "2000s Nostalgia Engine", body: "You like that gritty glow-up era: iconic openings, iconic fits, iconic arcs." };
        if (d === 2010) return { title: "2010s Peak Modern Era", body: "You‚Äôre in the era of big hits and stacked seasonal lineups." };
        if (d >= 2020) return { title: "2020s New-Gen Energy", body: "You‚Äôre tapped into the current wave. New season, new obsession." };
        return { title: `${d}s Vibe`, body: "You‚Äôve got a distinct era preference ‚Äî and it shows." };
      }

      // Binge personality
      const bingeScore = totalEpisodes / Math.max(1, totalAnime); // eps per title
      let bingeName = "Casual Drip";
      let bingeDesc = "You watch when you feel like it. No pressure. Pure vibes.";
      if (totalEpisodes >= 350 || bingeScore >= 20) {
        bingeName = "Arc Speedrunner";
        bingeDesc = "If there‚Äôs a story, you‚Äôre finishing it. Sleep is optional.";
      } else if (totalEpisodes >= 180 || bingeScore >= 12) {
        bingeName = "Weekend Grinder";
        bingeDesc = "You binge in bursts. One good weekend and your list jumps.";
      } else if (avgScore && avgScore >= 8.2) {
        bingeName = "Quality Sniper";
        bingeDesc = "You don‚Äôt binge everything ‚Äî you lock in only when it‚Äôs worth it.";
      }

      // Percentile-ish / club (existing)
      let percentileLabel = "top 50%";
      if (totalEpisodes >= 500) percentileLabel = "top 10%";
      else if (totalEpisodes >= 250) percentileLabel = "top 20%";
      else if (totalEpisodes >= 100) percentileLabel = "top 35%";
      else if (totalEpisodes <= 20) percentileLabel = "top 70%";

      let clubName = "Casual Viewer Club";
      let clubDesc = "You watch at your own pace ‚Äî enough to keep up, not enough to lose sleep... usually.";
      if (totalEpisodes >= 300) {
        clubName = "Shonen Grind Club";
        clubDesc = "You commit. Long runs, stacked arcs, and hundreds of episodes don‚Äôt scare you.";
      } else if (avgScore && avgScore >= 8.5) {
        clubName = "Quality Hunter Club";
        clubDesc = "You don‚Äôt waste time ‚Äî you laser in on high-rated shows and skip mid anime.";
      } else if (avgScore && avgScore <= 6.5) {
        clubName = "Villain Arc Club";
        clubDesc = "You keep watching mid or bad shows just to see how wild it gets. Respect.";
      }

      // Recs (upgrade: prefer top genre)
      const allTitlesLower = new Set(list.map(e => e.title.toLowerCase()));
      const recPool = [
        "Monster","Made in Abyss","Mob Psycho 100","Kaguya-sama: Love is War","Vinland Saga","Jujutsu Kaisen",
        "Re:Zero kara Hajimeru Isekai Seikatsu","Fruits Basket (2019)","Steins;Gate","Ping Pong the Animation",
        "Demon Slayer: Kimetsu no Yaiba","Chainsaw Man","Oshi no Ko","Bocchi the Rock!","Banana Fish","86",
        "Fullmetal Alchemist: Brotherhood","Gintama","Haikyuu!!","Code Geass"
      ];
      const unseenCandidates = recPool.filter(title => !allTitlesLower.has(title.toLowerCase()));
      const shuffled = shuffleArray(unseenCandidates.length ? unseenCandidates : recPool);
      const recommendations = shuffled.slice(0, 4);

      // -------------------------
      // SLIDES (including the NEW ones you listed)
      // -------------------------
      slides.push({
        type: "intro",
        kicker: "Welcome back to your year in anime",
        title: "This is your Anime Wrapped.",
        highlight: null,
        body: `We scanned your MyAnimeList export, tallied every episode, and did the math you were a little scared to see.`,
        extra: { username, year },
        backgroundImage: mostWatched ? coverForEntry(mostWatched) : ""
      });

      slides.push({
        type: "minutes",
        kicker: "Time spent in other worlds",
        title: "You watched " + formatNumber(totalMinutes) + " minutes of anime.",
        highlight: "That‚Äôs a lot of opening songs you didn‚Äôt skip.",
        body: "Here‚Äôs what that watch time looks like when you zoom out.",
        stats: [
          { label: "Seconds", value: formatNumber(Math.round(seconds)) },
          { label: "Hours", value: formatNumber((totalMinutes / 60) | 0) },
          { label: "Days", value: formatNumber(days.toFixed(1)) },
          { label: "Months (approx)", value: formatNumber(months.toFixed(2)) },
          { label: "Years (if it were one long show)", value: years.toFixed(3) }
        ],
        backgroundImage: mostWatched ? coverForEntry(mostWatched) : ""
      });

      // ‚úÖ NEW: Binge personality
      slides.push({
        type: "binge",
        kicker: "Your binge personality",
        title: bingeName,
        highlight: null,
        body: bingeDesc,
        stats: [
          { label: "Episodes logged", value: formatNumber(totalEpisodes) },
          { label: "Anime tracked", value: formatNumber(totalAnime) },
          { label: "Avg eps per title", value: (totalAnime ? (totalEpisodes / totalAnime).toFixed(1) : "‚Äî") }
        ],
        backgroundImage: mostWatched ? coverForEntry(mostWatched) : ""
      });

      if (mostWatched) {
        const mwMinutes = estimateMinutes(mostWatched);
        slides.push({
          type: "mostWatched",
          kicker: "The anime that owned your year",
          title: mostWatched.title,
          highlight: `You spent about ${formatNumber(mwMinutes)} minutes with this show.`,
          body: "If your life had opening credits this year, this is probably the anime they‚Äôd pull footage from.",
          stats: [
            { label: "Episodes watched", value: mostWatched.watchedEpisodes },
            { label: "Type", value: mostWatched.type || "Unknown" },
            { label: "Your score", value: mostWatched.score || "‚Äî" }
          ],
          extraAnime: mostWatched,
          backgroundImage: coverForEntry(mostWatched)
        });
      }

      // ‚úÖ NEW: Completed vs Dropped
      slides.push({
        type: "cd",
        kicker: "Completion energy",
        title: "Completed vs dropped",
        highlight: null,
        body: "Whether you finish every arc‚Ä¶ or bail when it gets mid.",
        stats: [
          { label: "Completed", value: formatNumber(completedCount) },
          { label: "Dropped", value: formatNumber(droppedCount) },
          { label: "Other / in-progress", value: formatNumber(Math.max(0, totalAnime - completedCount - droppedCount)) }
        ],
        backgroundImage: mostWatched ? coverForEntry(mostWatched) : ""
      });

      // ‚úÖ NEW: Most active month
      slides.push({
        type: "month",
        kicker: "When you were locked in",
        title: mostActiveMonth ? `Most active month: ${mostActiveMonth}` : "Most active month: Unknown",
        highlight: mostActiveMonth ? `You were on a run in ${mostActiveMonth}.` : "Add start/finish dates to your MAL list for this one to be exact.",
        body: "We count titles with a start/finish date in that month (best-effort).",
        stats: mostActiveMonth ? [
          { label: "Titles tagged in that month", value: formatNumber(monthCounts[bestMonthIdx]) }
        ] : [],
        backgroundImage: mostWatched ? coverForEntry(mostWatched) : ""
      });

      // ‚úÖ NEW: Fastest finish
      slides.push({
        type: "fastest",
        kicker: "Speedrun moment",
        title: fastest ? `Fastest finish: ${fastest.e.title}` : "Fastest finish: Not enough date data",
        highlight: fastest ? `${fastest.diffDays} day(s) from start to finish.` : "If your MAL export has start/finish dates, this slide becomes üî•.",
        body: "This is based on the shortest gap between start and finish dates.",
        stats: fastest ? [
          { label: "Days", value: formatNumber(fastest.diffDays) },
          { label: "Episodes logged", value: formatNumber(fastest.e.watchedEpisodes || 0) }
        ] : [],
        backgroundImage: fastest ? coverForEntry(fastest.e) : (mostWatched ? coverForEntry(mostWatched) : "")
      });

      // Highest / Lowest (existing)
      if (topRated.length) {
        slides.push({
          type: "highestRated",
          kicker: "Stories that actually hit",
          title: "Anime you rated the highest.",
          highlight: "These are the shows that stuck the landing for you.",
          body: "Whether it was story, characters, or pure vibes, these shows cleared your personal bar.",
          list: topRated.map(e => ({ title: e.title, score: e.score, episodes: e.watchedEpisodes, type: e.type })),
          backgroundImage: coverForEntry(topRated[0])
        });
      }

      if (bottomRated.length) {
        slides.push({
          type: "lowestRated",
          kicker: "Anime you wish you could leave behind",
          title: "Your lowest-rated watches.",
          highlight: "Not every show can be a W. These ones tested your patience.",
          body: "Maybe you finished them out of stubbornness. Maybe you dropped them mid-arc. Either way, they made the list.",
          list: bottomRated.map(e => ({ title: e.title, score: e.score, episodes: e.watchedEpisodes, type: e.type })),
          backgroundImage: coverForEntry(bottomRated[0])
        });
      }

      // ‚úÖ NEW: Top genre personality (enriched meta)
      slides.push({
        type: "genre",
        kicker: "Your top genre personality",
        title: topGenre ? `${topGenre[0]} Brain` : "Top genre: (needs meta)",
        highlight: topGenre ? `You touched ${topGenre[1]} title(s) with ${topGenre[0]} vibes.` : "This slide improves when we can fetch genres via Jikan (MAL ids).",
        body: topGenre ? genrePersonalityText(topGenre[0]) : "If you used manual list only, genres aren‚Äôt available. Upload XML or use MAL login for genre/studio slides.",
        stats: topGenre ? [
          { label: "Top genre", value: topGenre[0] },
          { label: "Genre hits", value: formatNumber(topGenre[1]) }
        ] : [],
        backgroundImage: mostWatched ? coverForEntry(mostWatched) : ""
      });

      // ‚úÖ NEW: Top studio loyalty (enriched meta)
      slides.push({
        type: "studio",
        kicker: "Studio loyalty",
        title: topStudio ? `You kept running into: ${topStudio[0]}` : "Top studio: (needs meta)",
        highlight: topStudio ? `${topStudio[1]} title(s) from that studio showed up in your run.` : "Upload XML / MAL login so we can fetch studio data.",
        body: topStudio ? "You‚Äôve basically got a studio taste profile at this point." : "Studios show up after meta enrichment.",
        stats: topStudio ? [
          { label: "Top studio", value: topStudio[0] },
          { label: "Titles", value: formatNumber(topStudio[1]) }
        ] : [],
        backgroundImage: mostWatched ? coverForEntry(mostWatched) : ""
      });

      // ‚úÖ NEW: Comfort anime (best-effort)
      slides.push({
        type: "comfort",
        kicker: "Comfort anime",
        title: comfortCandidate ? comfortCandidate.title : "Comfort anime: Unknown",
        highlight: comfortCandidate ? "This is the one that feels like home." : null,
        body: comfortCandidate
          ? "Best-guess pick: high score + ‚Äòyou come back to this‚Äô energy."
          : "Add scores/dates so we can detect your comfort watch more accurately.",
        stats: comfortCandidate ? [
          { label: "Your score", value: comfortCandidate.score || "‚Äî" },
          { label: "Minutes (est.)", value: formatNumber(estimateMinutes(comfortCandidate)) }
        ] : [],
        backgroundImage: comfortCandidate ? coverForEntry(comfortCandidate) : (mostWatched ? coverForEntry(mostWatched) : "")
      });

      // ‚úÖ NEW: Era vibe (enriched meta)
      const vibe = decadeVibe(topDecade ? topDecade[0] : null);
      slides.push({
        type: "era",
        kicker: "Anime era vibe",
        title: vibe.title,
        highlight: topDecade ? `Most of your enriched picks cluster in the ${topDecade[0]}s.` : "Era detection needs anime year meta (best with MAL ids).",
        body: vibe.body,
        stats: topDecade ? [
          { label: "Top decade", value: `${topDecade[0]}s` },
          { label: "Titles (enriched sample)", value: formatNumber(topDecade[1]) }
        ] : [],
        backgroundImage: mostWatched ? coverForEntry(mostWatched) : ""
      });

      // Existing count + club
      slides.push({
        type: "count",
        kicker: "How deep you went",
        title: `You watched or tracked ${formatNumber(totalAnime)} anime in ${year}.`,
        highlight: `On our scale, that puts you in the ${percentileLabel} of anime enjoyers.`,
        body: "This isn‚Äôt an official MAL stat, but based on your total episodes, you‚Äôre well above the average casual watcher.",
        stats: [
          { label: "Total anime in list (this run)", value: totalAnime },
          { label: "Total episodes watched", value: formatNumber(totalEpisodes) },
          { label: "Average score", value: avgScore ? avgScore.toFixed(2) : "‚Äî" }
        ],
        backgroundImage: mostWatched ? coverForEntry(mostWatched) : ""
      });

      slides.push({
        type: "club",
        kicker: "The club you belong to",
        title: clubName,
        highlight: null,
        body: clubDesc,
        stats: [
          { label: "Episodes logged", value: formatNumber(totalEpisodes) },
          { label: "Rated titles", value: rated.length },
          { label: "Average score vibe", value: avgScore ? avgScore.toFixed(2) : "mysterious" }
        ],
        backgroundImage: mostWatched ? coverForEntry(mostWatched) : ""
      });

      // Recs (existing)
      slides.push({
        type: "recs",
        kicker: "Fuel for your next year",
        title: "Some shows you might vibe with next.",
        highlight: recommendations.length
          ? "Based on your watch habits, here are a few popular picks you haven‚Äôt logged yet."
          : "You‚Äôve logged a lot already ‚Äî here are some evergreen suggestions anyway.",
        body: "This isn‚Äôt a perfect algorithm ‚Äî just a starting point of strong series to consider if you haven‚Äôt seen them yet.",
        recs: recommendations.length ? recommendations : recPool.slice(0, 4),
        backgroundImage: recommendations[0] ? placeholderCover(recommendations[0]) : placeholderCover(recPool[0])
      });

      slides.push({
        type: "outro",
        kicker: "Another year of anime down",
        title: "See you in next year‚Äôs recap.",
        highlight: "Here‚Äôs to better arcs, cleaner endings, and fewer mid shows in your queue.",
        body: "Screenshot the slides you like, send them to friends, or just use this as proof that your watch list is absolutely stacked.",
        extra: { username, year },
        backgroundImage: mostWatched ? coverForEntry(mostWatched) : ""
      });

      return slides;
    }

    // ============================
    // ------------- Render slides -------------
    // ============================
    let currentSlides = [];
    let currentSlideIndex = 0;

    // ‚úÖ Autoplay OP only AFTER user clicks Next/Prev/Restart once
    let opAutoEnabled = false;

    function setGlobalBackgroundAnime(imageUrl) {
      const bgAnimeDiv = document.querySelector(".bg-anime");
      if (bgAnimeDiv && imageUrl) {
        bgAnimeDiv.style.backgroundImage = `url('${imageUrl}')`;
        bgAnimeDiv.style.opacity = "0.32";
      }
    }

    function onSlideChanged() {
      if (!currentSlides.length) return;
      const slideData = currentSlides[currentSlideIndex];
      if (slideData && slideData.backgroundImage) setGlobalBackgroundAnime(slideData.backgroundImage);
    }

    function getAnimeTitleForSlide(slide) {
      return (
        (slide?.extraAnime && slide.extraAnime.title) ||
        (slide?.list && slide.list[0] && slide.list[0].title) ||
        (slide?.type === "comfort" && slide?.title) ||
        (slide?.recs && slide.recs[0]) ||
        ""
      );
    }

    function renderSlides(slides) {
      currentSlides = slides || [];
      currentSlideIndex = 0;
      opAutoEnabled = false;

      const container = document.getElementById("slidesMain");
      container.innerHTML = "";

      slides.forEach((slide, index) => {
        const slideEl = document.createElement("section");
        slideEl.className = "slide" + (index === 0 ? " active" : "");

        const bgDiv = document.createElement("div");
        bgDiv.className = "slide-bg";
        bgDiv.style.backgroundImage = slide.backgroundImage
          ? `url('${slide.backgroundImage}')`
          : "radial-gradient(circle at top left, rgba(249,115,22,0.3), rgba(15,23,42,1))";

        const gradDiv = document.createElement("div");
        gradDiv.className = "slide-gradient";

        const contentDiv = document.createElement("div");
        contentDiv.className = "slide-content";

        const leftDiv = document.createElement("div");
        leftDiv.className = "slide-left";

        const kicker = document.createElement("div");
        kicker.className = "slide-kicker";
        kicker.textContent = slide.kicker || "";

        const title = document.createElement("div");
        title.className = "slide-title";
        title.textContent = slide.title || "";

        leftDiv.appendChild(kicker);
        leftDiv.appendChild(title);

        if (slide.type === "intro") {
          const usernameEl = document.createElement("div");
          usernameEl.className = "intro-username";
          usernameEl.textContent = slide.extra?.username || "Anime Fan";

          const tagline = document.createElement("div");
          tagline.className = "intro-tagline";
          tagline.textContent = `A quick look at how you watched anime in ${slide.extra?.year}.`;

          leftDiv.appendChild(usernameEl);
          leftDiv.appendChild(tagline);
        }

        if (slide.highlight) {
          const highlight = document.createElement("div");
          highlight.className = "slide-highlight";
          highlight.textContent = slide.highlight;
          leftDiv.appendChild(highlight);
        }

        if (slide.body) {
          const body = document.createElement("div");
          body.className = "slide-body";
          body.textContent = slide.body;
          leftDiv.appendChild(body);
        }

        if (slide.stats && slide.stats.length) {
          const statsGrid = document.createElement("div");
          statsGrid.className = "stats-grid";
          slide.stats.forEach(row => {
            const rowEl = document.createElement("div");
            rowEl.className = "stats-row";

            const labelEl = document.createElement("div");
            labelEl.className = "stats-label";
            labelEl.textContent = row.label;

            const valEl = document.createElement("div");
            valEl.className = "stats-value";
            valEl.textContent = row.value;

            rowEl.appendChild(labelEl);
            rowEl.appendChild(valEl);
            statsGrid.appendChild(rowEl);
          });
          leftDiv.appendChild(statsGrid);
        }

        const rightDiv = document.createElement("div");
        rightDiv.className = "slide-right";

        if (slide.type === "mostWatched" && slide.extraAnime) {
          const card = document.createElement("div");
          card.className = "anime-card";

          const t = document.createElement("div");
          t.className = "anime-title";
          t.textContent = slide.extraAnime.title;

          const meta = document.createElement("div");
          meta.className = "anime-meta";
          meta.textContent = (slide.extraAnime.type || "Unknown type") + " ¬∑ " + slide.extraAnime.watchedEpisodes + " eps logged";

          const pillRow = document.createElement("div");
          pillRow.className = "pill-meta-row";

          const pill1 = document.createElement("div");
          pill1.className = "pill-meta";
          pill1.textContent = "Your score: " + (slide.extraAnime.score || "‚Äî");

          const pill2 = document.createElement("div");
          pill2.className = "pill-meta";
          pill2.textContent = "Est. minutes: " + formatNumber(estimateMinutes(slide.extraAnime));

          pillRow.appendChild(pill1);
          pillRow.appendChild(pill2);

          card.appendChild(t);
          card.appendChild(meta);
          card.appendChild(pillRow);
          rightDiv.appendChild(card);

        } else if (slide.type === "highestRated" || slide.type === "lowestRated") {
          const card = document.createElement("div");
          card.className = "anime-card";

          const header = document.createElement("div");
          header.className = "anime-title";
          header.textContent = slide.type === "highestRated" ? "Your top-rated picks" : "Your lowest-rated picks";
          card.appendChild(header);

          (slide.list || []).forEach(item => {
            const row = document.createElement("div");
            row.className = "anime-meta";
            row.textContent = `${item.title} ¬∑ Score: ${item.score} ¬∑ ${item.episodes} eps`;
            card.appendChild(row);
          });

          rightDiv.appendChild(card);

        } else if (slide.type === "recs") {
          const card = document.createElement("div");
          card.className = "anime-card";

          const header = document.createElement("div");
          header.className = "anime-title";
          header.textContent = "Try these next year";
          card.appendChild(header);

          (slide.recs || []).forEach(titleStr => {
            const row = document.createElement("div");
            row.className = "anime-meta";
            row.textContent = titleStr;
            card.appendChild(row);
          });

          rightDiv.appendChild(card);

        } else {
          const card = document.createElement("div");
          card.className = "anime-card";

          const header = document.createElement("div");
          header.className = "anime-title";
          header.textContent =
            slide.type === "binge" ? "Binge profile" :
            slide.type === "cd" ? "Completion stats" :
            slide.type === "month" ? "Monthly activity" :
            slide.type === "fastest" ? "Speedrun stats" :
            slide.type === "genre" ? "Genre profile" :
            slide.type === "studio" ? "Studio profile" :
            slide.type === "comfort" ? "Comfort pick" :
            slide.type === "era" ? "Era profile" :
            slide.type === "club" ? "Your watching profile" :
            slide.type === "count" ? "Quick stats" :
            slide.type === "intro" ? "What you‚Äôre about to see" : "Your next arc";

          const meta = document.createElement("div");
          meta.className = "anime-meta";
          meta.textContent =
            slide.type === "intro" ? "Total episodes, minutes, highs, lows, and a few gentle roasts about your watch habits." :
            slide.type === "outro" ? "Set some goals: finish that one show, clear a backlog, or finally watch that recommendation." :
            slide.type === "club" ? "This is our read on how you approach anime as a whole." :
            "Extra stats that make it feel like a real Wrapped.";

          card.appendChild(header);
          card.appendChild(meta);
          rightDiv.appendChild(card);
        }

        const foot = document.createElement("div");
        foot.className = "slide-footer";
        if (slide.type === "minutes") foot.textContent = "Minutes estimated at ~23 minutes per episode (movies as ~90m each).";
        else if (slide.type === "count") foot.textContent = "Percentile is a fun estimate ‚Äî not an official MAL metric.";
        else if (slide.type === "recs") foot.textContent = "We only recommend shows that don‚Äôt appear in your list export.";
        else if (slide.type === "genre" || slide.type === "studio" || slide.type === "era") foot.textContent = "Genre/Studio/Era uses meta enrichment (best with MAL IDs).";
        else foot.textContent = "";
        rightDiv.appendChild(foot);

        contentDiv.appendChild(leftDiv);
        contentDiv.appendChild(rightDiv);

        slideEl.appendChild(bgDiv);
        slideEl.appendChild(gradDiv);
        slideEl.appendChild(contentDiv);

        container.appendChild(slideEl);
      });

      updateSlideIndicator();
      updateControlsDisabled();
      onSlideChanged();
    }

    function updateSlideIndicator() {
  const indicator = document.getElementById("slideIndicator");
  if (!indicator || !currentSlides.length) return;
  indicator.textContent = `Slide ${currentSlideIndex + 1} of ${currentSlides.length}`;
}

function updateControlsDisabled() {
  const prevBtn = document.getElementById("prevSlideBtn");
  const nextBtn = document.getElementById("nextSlideBtn");
  if (!prevBtn || !nextBtn) return;

  if (!currentSlides.length) {
    prevBtn.disabled = true;
    nextBtn.disabled = true;
    return;
  }

  prevBtn.disabled = currentSlideIndex === 0;
  nextBtn.disabled = currentSlideIndex === currentSlides.length - 1;
}

function showSlide(index) {
  if (!currentSlides.length) return;

  const slidesEls = Array.from(document.querySelectorAll("#slidesMain .slide"));
  currentSlideIndex = clamp(index, 0, currentSlides.length - 1);

  slidesEls.forEach((el, i) => {
    el.classList.toggle("active", i === currentSlideIndex);
  });

  updateSlideIndicator();
  updateControlsDisabled();
  onSlideChanged();

  // ‚úÖ only autoplay OP after user has interacted with nav at least once
  if (opAutoEnabled) {
    const s = currentSlides[currentSlideIndex];
    const t = getAnimeTitleForSlide(s);
    if (t) playOpeningForAnime(t);
  }
}

    function nextSlide() {
      opAutoEnabled = true;
      showSlide(currentSlideIndex + 1);
    }

    function prevSlide() {
      opAutoEnabled = true;
      showSlide(currentSlideIndex - 1);
    }

    function restartSlides() {
      opAutoEnabled = true;
      showSlide(0);
    }

    // Buttons
    const prevSlideBtn = document.getElementById("prevSlideBtn");
    const nextSlideBtn = document.getElementById("nextSlideBtn");
    const restartBtn = document.getElementById("restartBtn");

    if (prevSlideBtn) prevSlideBtn.addEventListener("click", prevSlide);
    if (nextSlideBtn) nextSlideBtn.addEventListener("click", nextSlide);
    if (restartBtn) restartBtn.addEventListener("click", restartSlides);

    // Keyboard arrows
    window.addEventListener("keydown", (e) => {
      const activeSlides = document.getElementById("panel-slides")?.classList.contains("active");
      if (!activeSlides) return;
      if (e.key === "ArrowRight") nextSlide();
      if (e.key === "ArrowLeft") prevSlide();
    });

    // ============================
    // ‚úÖ Slide "Play Opening" button wiring
    // (Fixes: unclickable / only one anime playing)
    // ============================
    function injectPlayButtons() {
      const slideEls = Array.from(document.querySelectorAll("#slidesMain .slide"));
      slideEls.forEach((slideEl, idx) => {
        const slideData = currentSlides[idx];
        if (!slideData) return;

        // Only inject once
        if (slideEl.querySelector(".play-op-btn")) return;

        const titleToPlay = getAnimeTitleForSlide(slideData);
        if (!titleToPlay) return;

        // Put button inside right card if possible
        const rightCard = slideEl.querySelector(".slide-right .anime-card");
        if (!rightCard) return;

        const btn = document.createElement("button");
        btn.className = "control-btn play-op-btn";
        btn.type = "button";
        btn.style.marginTop = "10px";
        btn.style.width = "100%";
        btn.innerHTML = "‚ñ∂ Play opening";

        btn.addEventListener("click", () => {
          opAutoEnabled = true; // counts as user interaction
          playOpeningForAnime(titleToPlay);
        });

        rightCard.appendChild(btn);
      });
    }

    // Patch renderSlides so it injects buttons after rendering
    const _renderSlides = renderSlides;
    renderSlides = function(slides) {
      _renderSlides(slides);
      injectPlayButtons();
    };

    // ============================
    // ------------- File read (XML / GZ) -------------
    // ============================
    async function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    async function readFileAsText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsText(file);
      });
    }

    async function parseUploadFile(file) {
      const name = (file?.name || "").toLowerCase();

      if (name.endsWith(".gz")) {
        const buf = await readFileAsArrayBuffer(file);
        const uint8 = new Uint8Array(buf);
        const decompressed = window.pako.ungzip(uint8, { to: "string" });
        return String(decompressed || "");
      }

      // xml or txt
      const text = await readFileAsText(file);
      return String(text || "");
    }

    // ============================
    // ------------- Main generate flow -------------
    // ============================
    const malInput = document.getElementById("malFile");
    const yearInput = document.getElementById("yearInput");
    const fileError = document.getElementById("fileError");
    const generateBtn = document.getElementById("generateBtn");
    const usernameInput = document.getElementById("malUsername");
    const manualListInput = document.getElementById("manualList");

    // default year
    const currentYear = new Date().getFullYear();
    if (yearInput && !yearInput.value) yearInput.value = currentYear;

    // MAL login button (already in your HTML)
    const malLoginBtn = document.getElementById("malLoginBtn");
    if (malLoginBtn) {
      malLoginBtn.addEventListener("click", () => {
        window.localStorage.setItem("malAuthorized", "true");
        window.open("https://mal-wrapped-1.onrender.com/login", "_blank");
      });
    }

    function setError(msg) {
      if (!fileError) return;
      if (!msg) {
        fileError.style.display = "none";
        fileError.textContent = "";
      } else {
        fileError.style.display = "block";
        fileError.textContent = msg;
      }
    }

    function setLoaderHint(text) {
      const hint = document.getElementById("loaderHint");
      if (hint) hint.textContent = text;
    }

    async function generateWrapped() {
      setError("");
      closeYtModal(); // keep UI clean
      stopBgMusic();
      stopOpSample();

      const yearVal = safeInt(yearInput?.value || currentYear, currentYear);

      const file = malInput?.files?.[0] || null;
      const username = (usernameInput?.value || "").trim();
      const manualText = (manualListInput?.value || "").trim();
      const hasAuthorized = window.localStorage.getItem("malAuthorized") === "true";

      showPanel("panel-loading");
      setLoaderHint("Parsing your list...");

      try {
        let data = null;

        // 1) File upload wins
        if (file) {
          const raw = await parseUploadFile(file);

          // If they uploaded a txt manual list, treat it as manual format
          const isXml = raw.trim().startsWith("<?xml") || raw.includes("<myanimelist>");
          if (isXml) {
            const parsed = parseMalXml(raw);
            data = { userName: parsed.userName, year: yearVal, entries: parsed.entries };
          } else {
            // treat as manual lines
            data = parseManualList(raw, yearVal);
          }
        }
        // 2) If they clicked MAL login at least once, try backend
        else if (hasAuthorized) {
          setLoaderHint("Fetching from MAL login backend...");
          data = await fetchFromMalApi(yearVal);
        }
        // 3) Username via Jikan
        else if (username) {
          setLoaderHint("Fetching from Jikan (MAL mirror)...");
          data = await fetchFromJikan(username, yearVal);
        }
        // 4) Manual textarea
        else if (manualText) {
          data = parseManualList(manualText, yearVal);
        }

        if (!data || !data.entries || !data.entries.length) {
          throw new Error("No anime found. Upload XML/XML.GZ, use MAL login, enter username, or paste a manual list.");
        }

        setLoaderHint("Enriching genres / studios (best effort)...");
        await enrichEntriesWithMeta(data.entries);

        setLoaderHint("Building slides...");
        const slides = buildSlides(data);

        renderSlides(slides);
        showPanel("panel-slides");

        // set background to first slide‚Äôs bg image
        onSlideChanged();

      } catch (err) {
        console.error(err);
        showPanel("panel-input");
        setError(err?.message || "Something went wrong. Try again.");
      }
    }

    if (generateBtn) {
      generateBtn.addEventListener("click", generateWrapped);
    }
  </script>
</body>
</html>
